

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="冰红茶">
  <meta name="keywords" content="">
  
    <meta name="description" content="Liunx-IO1.基础概念1.1 Liunx的组成如下图所示，Liunx系统包含了内核、Shell、文件系统、应用系统   Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。 系统调用接口：SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分">
<meta property="og:type" content="article">
<meta property="og:title" content="liunx-IO">
<meta property="og:url" content="http://example.com/2023/10/10/liunx-IO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Liunx-IO1.基础概念1.1 Liunx的组成如下图所示，Liunx系统包含了内核、Shell、文件系统、应用系统   Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。 系统调用接口：SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010223007225.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010223213876.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010223620882.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010224322534-1697161520610-5.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010224514222-1697161551998-7.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010225314350.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011093416174.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011111441664.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011095934835.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011103101687.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011112434243.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011213646817.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011215103788.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231011220001774.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231012105822167.png">
<meta property="og:image" content="http://example.com/2023/10/10/liunx-IO/image-20231012105909004.png">
<meta property="article:published_time" content="2023-10-10T14:19:54.000Z">
<meta property="article:modified_time" content="2023-10-13T09:04:18.981Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="秋招-liunx">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/10/10/liunx-IO/image-20231010223007225.png">
  
  
  
  <title>liunx-IO - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"P2Cpc6lvLMUQtZgsW53ZKoJr-gzGzoHsz","app_key":"FG06QwK7ytaQLAShY5fsaH4y","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/moon.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="liunx-IO"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-10 22:19" pubdate>
          2023年10月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          78 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">liunx-IO</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Liunx-IO"><a href="#Liunx-IO" class="headerlink" title="Liunx-IO"></a>Liunx-IO</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><h3 id="1-1-Liunx的组成"><a href="#1-1-Liunx的组成" class="headerlink" title="1.1 Liunx的组成"></a>1.1 Liunx的组成</h3><p>如下图所示，Liunx系统包含了内核、Shell、文件系统、应用系统</p>
<img src="/2023/10/10/liunx-IO/image-20231010223007225.png" srcset="/img/loading.gif" lazyload class title="image-20231010223007225">

<p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p>
<p><strong>系统调用接口：</strong>SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p>
<img src="/2023/10/10/liunx-IO/image-20231010223213876.png" srcset="/img/loading.gif" lazyload class title="image-20231010223213876">

<h3 id="1-2-用户空间与内核空间"><a href="#1-2-用户空间与内核空间" class="headerlink" title="1.2 用户空间与内核空间"></a>1.2 用户空间与内核空间</h3><p>对于Linux操作系统而言，其核心是内核，内核独立于普通的应用程序。操作系统为了支持多个应用同时进行，需保证不同进程之间的相对独立（一个进程崩溃不会影响其他进程，恶意进程不能直接读取或修改其他进程运行时的代码或数据）。因此操作系统内核需要用有比普通进程更高的权限，以此来调度和管理用户的应用程序，同时也可以保证内核的安全。</p>
<p>因此内存空间被划分为内核空间、用户空间。内核可以访问受保护的内核空间，也有访问底层硬件设备的所有权限。</p>
<p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<img src="/2023/10/10/liunx-IO/image-20231010223620882.png" srcset="/img/loading.gif" lazyload class title="image-20231010223620882">

<h3 id="1-3-进程切换"><a href="#1-3-进程切换" class="headerlink" title="1.3 进程切换"></a>1.3 进程切换</h3><p>为了管理进程，内核必须有挂起、恢复某个进程的能力。此种行为称为上下文切换。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">保存CPU上下文信息，包括程序计数器、其他寄存器<br>更新PCB信息<br>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列<br>选择另一个进程执行，并更新其PCB<br>更新内存管理的数据结构<br></code></pre></td></tr></table></figure>

<p>总结：上下文切换需要进行一系列复杂的操作，很消耗资源</p>
<h3 id="1-4-进程的阻塞"><a href="#1-4-进程的阻塞" class="headerlink" title="1.4 进程的阻塞"></a>1.4 进程的阻塞</h3><p><strong>正在执行的进程，当它无法获取到所需的资源（比如请求系统资源失败、等待某种操作完成、新数据尚未到达或无新的工作任务），则由系统执行阻塞原语（Block），使自己由运行状态变为阻塞状态。</strong> 只有处于运行态的进程才可能将其转为阻塞状态。阻塞态的进程不占用CPU资源。</p>
<h3 id="1-5-文件与文件描述符"><a href="#1-5-文件与文件描述符" class="headerlink" title="1.5 文件与文件描述符"></a>1.5 文件与文件描述符</h3><p>Linux中一切皆文件，包括普通文件、套接字、字符设备文件（键盘、鼠标等等）、块设备文件（光驱、硬盘），这些都抽象成文件</p>
<p>文件描述符，File Descriptor，简称fd。其本质是一个非负整数。当程序打开或创建一个文件，内核都会返回一个非负整数，即文件描述符。此非负整数对应内核为每个进程所维护的该进程打开文件的记录表中的一条记录，即非负整数对应一个表上的一条记录。如下图所示：</p>
<img src="/2023/10/10/liunx-IO/image-20231010224322534-1697161520610-5.png" srcset="/img/loading.gif" lazyload class title="image-20231010224322534">

<p>如上图所示，进程A中文件描述符1和3都指向同一个句柄13，这可能是该进程A多次执行打开同一个文件操作。</p>
<p>总结：进程拿到文件描述符，去进程对应的文件描述符表查询到文件指针，文件指针指向系统级别的打开文件表的文件偏移量，通过文件偏移量拿到i-node指针，最终找到真实的文件。</p>
<p><strong>小结：</strong></p>
<p>当用户打开一个文件，用户只得到了一个 <code>fd</code> 句柄，但内核做了很多事情，梳理下来，我们得到几个关键的数据结构，这几个数据结构是有层次递进关系的，我们简单梳理下：</p>
<ol>
<li>进程结构 <code>task_struct</code> ：表征进程实体，每一个进程都和一个 <code>task_struct</code> 结构体对应，其中 <code>task_struct.files</code> 指向一个管理打开文件的结构体 <code>fiels_struct</code> ；</li>
<li>文件表项管理结构 <code>files_struct</code> ：用于管理进程打开的 open 文件列表，内部以数组的方式实现（静态数组和动态数组结合）。返回给用户的 <code>fd</code> 就是这个数组的<strong>编号索引</strong>而已，索引元素为 <code>file</code> 结构；</li>
</ol>
<ul>
<li><strong><code>files_struct</code> 只从属于某进程；</strong></li>
</ul>
<p>​	文件 <code>file</code> 结构：表征一个打开的文件，内部包含关键的字段有：<strong>当前文件偏移，inode 结构地址</strong>；</p>
<ul>
<li><strong>该结构虽然由进程触发创建，但是 <code>file</code> 结构可以在进程间共享；</strong></li>
</ul>
<p>​	<code>vfs inode</code> 结构体：文件 <code>file</code> 结构指向 的是 vfs 的 <code>inode</code> ，这个是操作系统抽象出来的一层，用于屏蔽后端各种各样的文件系统的 <code>inode</code> 差异；</p>
<ul>
<li><strong>inode 这个具体进程无关，是文件系统级别的资源；</strong></li>
</ul>
<p>​	<code>ext4 inode</code> 结构体（指代具体文件系统 inode ）：后端文件系统的 <code>inode</code> 结构，不同文件系统自定义的结构体，ext2 有 <code>ext2_inode_info</code>，ext4 有<code>ext4_inode_info</code>，minix 有 <code>minix_inode_info</code>，这些结构里都是内嵌了一个 vfs <code>inode</code> 结构体，原理相同；</p>
<img src="/2023/10/10/liunx-IO/image-20231010224514222-1697161551998-7.png" srcset="/img/loading.gif" lazyload class title="image-20231010224514222">

<p><strong>Liunx内核的VFS子系统</strong></p>
<img src="/2023/10/10/liunx-IO/image-20231010225314350.png" srcset="/img/loading.gif" lazyload class title="image-20231010225314350">

<p>​	文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。</p>
<p>​	在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是<strong>对应不同的file结构体，因此可以有不同的File Status Flag和读写位置</strong>。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。</p>
<p>​	每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。</p>
<p>​	file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p>
<p>​	每个file结构体都有一个指向dentry结构体的指针，<strong>“dentry”是directory entry（目录项）的缩写</strong>。我们传给open、stat等函数的参数的是一个路径，例如&#x2F;home&#x2F;akaedu&#x2F;a，需要根据路径找到文件的inode。<strong>为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache</strong>，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录&#x2F;找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p>
<p>​	每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示&#x2F;home&#x2F;akaedu&#x2F;a和&#x2F;home&#x2F;akaedu&#x2F;b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。</p>
<p>​	和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。</p>
<p>​	inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到&#x2F;home目录下。</p>
<p>​	file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p>
<h3 id="1-6-缓存IO"><a href="#1-6-缓存IO" class="headerlink" title="1.6 缓存IO"></a>1.6 缓存IO</h3><p>缓存IO又被称作标准IO，在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中（page cache）。即数据先被拷贝到内核的缓冲区中，随后才会被拷贝到应用程序的地址空间。</p>
<p>优点：可以解决CPU与IO速度冲突问题</p>
<p>缺点：数据传输过程中，数据在进程的<strong>地址空间与内核空间进行多次数据拷贝操作</strong>，CPU以及内存开销都很大。</p>
<p>总结：网络IO就是操作系统接收网卡收到的数据，缓存到一个buffer中，应用程序调用操作系统的函数（就是操作系统提供的IO接口），从对应的buffer中取出数据。操作系统在网络IO过程中充当了一个提供抽象接口的角色</p>
<h2 id="2-Liunx-IO模型"><a href="#2-Liunx-IO模型" class="headerlink" title="2.Liunx IO模型"></a>2.Liunx IO模型</h2><p>网络IO的本质是socket的读取，socket会被Linux抽象成流，IO可以看作是对流的操作。以Read举例子，对于一次IO访问，<strong>数据先被拷贝到内核的缓冲区中，然后才从操作系统内核的缓冲区中拷贝到应用程序的地址空间</strong>。</p>
<p>当发生一次Read操作时，会发生以下2个阶段：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">等待数据准备<br>将数据从内核拷贝到进程中<br></code></pre></td></tr></table></figure>

<p>对于Socket流而言，发生如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">通常等待网络上其他数据分组到达，然后被复制到内核的某个缓冲区中<br>把数据从内核的缓冲区复制到应用进程缓冲区<br></code></pre></td></tr></table></figure>

<p>网络IO有如下几种：</p>
<ul>
<li>同步模型（synchronous IO）</li>
<li>阻塞IO（blocking IO）</li>
<li>非阻塞IO（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li>异步IO（asynchronous IO）</li>
</ul>
<h3 id="2-1-同步阻塞IO"><a href="#2-1-同步阻塞IO" class="headerlink" title="2.1 同步阻塞IO"></a>2.1 同步阻塞IO</h3><p>用户空间的进程执行一个系统调用，比如recvfrom，这会导致应用程序阻塞，期间什么都不干，直到数据准备好，并且数据被从内核缓冲区复制到用户进程</p>
<img src="/2023/10/10/liunx-IO/image-20231011093416174.png" srcset="/img/loading.gif" lazyload class title="image-20231011093416174">

<p>如上图所示，用户进程调用recvfrom这个系统调用，内核即开始IO的第一个阶段，对于网络IO来说，此时还未收到一个完整的数据包，通常需要等待其他数据报到来组成一个完整的数据包。这个过程是数据被复制到内核的某个缓冲区中。此时用户进程会自行阻塞。复制完后，进入第二个阶段。<strong>内核一直等到数据准备好了</strong>，就把数据从内核复制到用户空间。内核返回结果，用户进程解除阻塞状态，重新运行起来。</p>
<img src="/2023/10/10/liunx-IO/image-20231011111441664.png" srcset="/img/loading.gif" lazyload class title="image-20231011111441664">



<h3 id="2-2-同步非阻塞IO"><a href="#2-2-同步非阻塞IO" class="headerlink" title="2.2 同步非阻塞IO"></a>2.2 同步非阻塞IO</h3><p>用户进程调用recvfrom系统调用，进程没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时返回一个error。进程收到返回后做些别的事请，过一会再发起recvfrom系统调用。如此循环重复，此过程常称为轮询。直到数据准备好并且已经被复制到用户空间。如下图所示：</p>
<img src="/2023/10/10/liunx-IO/image-20231011095934835.png" srcset="/img/loading.gif" lazyload class title="image-20231011095934835">

<p>用户进程发出recvfrom操作，用户进程不会被阻塞，内核若还未准备好数据，则会返回一个error。<strong>此时用户进程可以干别的事请，过一会再调用recvfrom询问内核是否准备好了数据，此操作称为轮询</strong>。一旦内核准备好了数据并且用户进程前来询问，此时内核将数据复制到用户空间中并且返回。</p>
<h3 id="2-3-IO多路复用"><a href="#2-3-IO多路复用" class="headerlink" title="2.3 IO多路复用"></a>2.3 IO多路复用</h3><p>同步非阻塞IO是由用户进程去轮询内核是否准备好了数据。IO多路复用则使用<strong>一个特定的进程去轮询</strong>。这就是IO多路复用。常见的select、poll、epoll就是干这个的。select调用是内核级别的。select与同步非阻塞的区别在于：前者能等待多个socket，即能同时监听多个IO端口。当内核对任何一个socket准备好了部分数据（select无需等所有数据包到达内核后才开始，内核会负责监视是否有数据到达）就能返回，然后用户进程再进行recvfrom调用，将数据从内核复制到用户空间。</p>
<p>select、poll、epoll可以同时阻塞多个IO操作。直到内核监视到有数据到达内核，才真正调用IO操作函数。</p>
<img src="/2023/10/10/liunx-IO/image-20231011103101687.png" srcset="/img/loading.gif" lazyload class title="image-20231011103101687">

<p>IO multiplexing就是常说的select、poll、epoll。好处是用一个进程即可处理多个网络连接的IO。其原理是select、poll、epoll不断地轮询负责的socket，当某个socket有数据到达内核，就通知用户进程。</p>
<p>用户进程调用select，整个进程会被阻塞。内核监视select负责的所有socket，任何一个有数据准备好，select就返回。此时用户再调用recvfrom，将数据从内核拷贝到用户进程。</p>
<h4 id="2-3-1-select原理"><a href="#2-3-1-select原理" class="headerlink" title="2.3.1 select原理"></a><strong>2.3.1 select原理</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds,                     <span class="hljs-comment">// 监控的文件描述符集里最大文件描述符加1</span></span><br><span class="hljs-params">    fd_set *readfds,              <span class="hljs-comment">// 监控有读数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *writefds,             <span class="hljs-comment">// 监控写数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *exceptfds,            <span class="hljs-comment">// 监控异常发生达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout)</span>;     <span class="hljs-comment">// 定时阻塞监控时间</span><br></code></pre></td></tr></table></figure>

<p>readfds、writefds、errorfds 是三个文件描述符集合。select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换这三个引用参数中的对应集合，返回所有就绪描述符的数量。</p>
<p>timeout 参数表示调用 select 时的阻塞时长。如果所有 fd 文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。</p>
<p><strong>fd_set 文件描述符集合</strong></p>
<p>select 函数参数中的 fd_set 类型表示文件描述符的集合。</p>
<p>由于文件描述符 fd 是一个从 0 开始的无符号整数，所以可以使用 fd_set 的二进制每一位来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 fd_set 长度为 1 字节，则一个 fd_set 变量最大可以表示 8 个文件描述符。当 select 返回 fd_set &#x3D; 00010011 时，表示文件描述符 1、2、5 已经就绪。</p>
<img src="/2023/10/10/liunx-IO/image-20231011112434243.png" srcset="/img/loading.gif" lazyload class title="image-20231011112434243">

<img src="/2023/10/10/liunx-IO/image-20231011213646817.png" srcset="/img/loading.gif" lazyload class title="image-20231011213646817">

<h4 id="2-3-2-epoll实现原理"><a href="#2-3-2-epoll实现原理" class="headerlink" title="2.3.2 epoll实现原理"></a>2.3.2 epoll实现原理</h4><p>epoll 的特点是：</p>
<p>1）使用<strong>红黑树</strong>存储<strong>一份</strong>文件描述符集合，每个文件描述符只需在添加时传入一次，无需用户每次都重新传入；—— 解决了 select 中 fd_set 重复拷贝到内核的问题</p>
<p>2）通过异步 IO 事件找到就绪的文件描述符，而不是通过轮询的方式；</p>
<p>3）使用队列存储就绪的文件描述符，且会按需返回就绪的文件描述符，无须再次遍历；</p>
<p><strong>epoll_ctl</strong></p>
<p>epoll_ctl 函数主要负责把服务端和客户端建立的 socket 连接注册到 eventpoll 对象里，会做三件事：</p>
<p>1）创建一个 epitem 对象，主要包含两个字段，分别存放 socket fd 即连接的文件描述符，和所属的 eventpoll 对象的指针；</p>
<p>2）将一个数据到达时用到的回调函数添加到 socket 的进程等待队列中，注意，跟第 1.1 节的阻塞 IO 模式不同的是，这里添加的 socket 的进程等待队列结构中，只有回调函数，没有设置进程描述符，因为<strong>在 epoll 中，进程是放在 eventpoll 的等待队列中</strong>，等待被 epoll_wait 函数唤醒，而不是放在 socket 的进程等待队列中；</p>
<p>3）将第 1）步创建的 epitem 对象插入红黑树；</p>
<img src="/2023/10/10/liunx-IO/image-20231011215103788.png" srcset="/img/loading.gif" lazyload class title="image-20231011215103788">

<p><strong>epoll_wait</strong></p>
<p>epoll_wait 函数的动作比较简单，检查 eventpoll 对象的就绪的连接 rdllist 上是否有数据到达，如果没有就把当前的进程描述符添加到一个等待队列项里，加入到 eventpoll 的进程等待队列里，然后阻塞当前进程，等待数据到达时通过回调函数被唤醒。</p>
<p>当 eventpoll 监控的连接上有数据到达时，通过下面几个步骤唤醒对应的进程处理数据：</p>
<p>1）socket 的数据接收队列有数据到达，会通过进程等待队列的回调函数 ep_poll_callback 唤醒红黑树中的节点 epitem；</p>
<p>2）ep_poll_callback 函数将有数据到达的 epitem 添加到 eventpoll 对象的就绪队列 rdllist 中；</p>
<p>3）ep_poll_callback 函数检查 eventpoll 对象的进程等待队列上是否有等待项，通过回调函数 default_wake_func 唤醒这个进程，进行数据的处理；</p>
<p>4）当进程醒来后，继续从 epoll_wait 时暂停的代码继续执行，把 rdlist 中就绪的事件返回给用户进程，让用户进程调用 recv 把已经到达内核 socket 等待队列的数据拷贝到用户空间使用。</p>
<img src="/2023/10/10/liunx-IO/image-20231011220001774.png" srcset="/img/loading.gif" lazyload class title="image-20231011220001774">

<h4 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3 总结"></a>2.3.3 总结</h4><p>从阻塞 IO 到 epoll 的实现中，我们可以看到 <strong>wake up 回调函数机制</strong>被频繁的使用，至少有三处地方：一是阻塞 IO 中数据到达 socket 的等待队列时，通过回调函数唤醒进程，二是 epoll 中数据到达 socket 的等待队列时，通过回调函数 ep_poll_callback 找到 eventpoll 中红黑树的 epitem 节点，并将其加入就绪列队 rdllist，三是通过回调函数 default_wake_func 唤醒用户进程 ，并将 rdllist 传递给用户进程，让用户进程准确读取数据 。从中可知，这种回调机制能够定向准确的通知程序要处理的事件，而不需要每次都循环遍历检查数据是否到达以及数据该由哪个进程处理，提高了程序效率，在日常的业务开发中，我们也可以借鉴下这一机制。</p>
<h3 id="2-4-信号驱动式IO"><a href="#2-4-信号驱动式IO" class="headerlink" title="2.4 信号驱动式IO"></a>2.4 信号驱动式IO</h3><img src="/2023/10/10/liunx-IO/image-20231012105822167.png" srcset="/img/loading.gif" lazyload class title="image-20231012105822167">

<h3 id="2-5-异步IO"><a href="#2-5-异步IO" class="headerlink" title="2.5 异步IO"></a>2.5 异步IO</h3><img src="/2023/10/10/liunx-IO/image-20231012105909004.png" srcset="/img/loading.gif" lazyload class title="image-20231012105909004">

<p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p>
<h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p><strong>同步：</strong>发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 例如：B&#x2F;S模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。</p>
<p><strong>异步：</strong>异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p>
<p>对于通知调用者的三种方式，具体如下：</p>
<ul>
<li>状态</li>
</ul>
<p>即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p>
<ul>
<li>通知</li>
</ul>
<p>当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p>
<ul>
<li>回调</li>
</ul>
<p>与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p>
<p>例如：B&#x2F;S模式中的ajax请求，具体过程是：客户端发出ajax请求-&gt;服务端处理-&gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。</p>
<p><strong>总结来说，同步和异步的区别：请求发出后，是否需要等待结果，才能继续执行其他操作。</strong></p>
<p><strong>阻塞：</strong>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p>
<p><strong>非阻塞：</strong>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p><strong>总体来说：阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</strong></p>
<p><strong>同步阻塞</strong>：小明一直盯着下载进度条，到 100% 的时候就完成。 - 同步体现在：等待下载完成通知。 - 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理。</p>
<p><strong>同步非阻塞</strong>：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。 - 同步体现在：等待下载完成通知。 - 非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条。【小明必须要在两个任务间切换，关注下载进度】</p>
<p><strong>异步阻塞</strong>：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明不做别的事，仍然一直等待“叮”的声音。 - 异步体现在：下载完成“叮”一声通知。 - 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理。</p>
<p><strong>异步非阻塞</strong>：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 - 异步体现在：下载完成“叮”一声通知。 - 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%A7%8B%E6%8B%9B/" class="category-chain-item">秋招</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%A7%8B%E6%8B%9B-liunx/" class="print-no-link">#秋招-liunx</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>liunx-IO</div>
      <div>http://example.com/2023/10/10/liunx-IO/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>冰红茶</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="HTTP相关知识">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTTP相关知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/08/liunx%E5%91%BD%E4%BB%A4/" title="liunx命令">
                        <span class="hidden-mobile">liunx命令</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"P2Cpc6lvLMUQtZgsW53ZKoJr-gzGzoHsz","appKey":"FG06QwK7ytaQLAShY5fsaH4y","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/background.js"></script>
<script src="/alec_diy/live2d-widget/autoload.js"></script>
<script src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
