<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2023/10/29/SpringBoot1/"/>
    <url>/2023/10/29/SpringBoot1/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1-SpringMVC开发回顾"><a href="#1-SpringMVC开发回顾" class="headerlink" title="1.SpringMVC开发回顾"></a>1.SpringMVC开发回顾</h2><p>1.创建工程，并在 pom.xml 配置文件中配置所依赖的坐标</p><img src="/2023/10/29/SpringBoot1/image-20231029105446725.png" class title="image-20231029105446725"><p>2.编写 web3.0 的配置类</p><img src="/2023/10/29/SpringBoot1/image-20231029105503309.png" class title="image-20231029105503309"><p>3.编写 SpringMVC 的配置类</p><img src="/2023/10/29/SpringBoot1/image-20231029105526631.png" class title="image-20231029105526631"><p>4.编写 Controller 类</p><img src="/2023/10/29/SpringBoot1/image-20231029111331494.png" class title="image-20231029111331494"><h2 id="2-SpringBoot开发"><a href="#2-SpringBoot开发" class="headerlink" title="2.SpringBoot开发"></a>2.SpringBoot开发</h2><p><code>SpringBoot</code> 开发起来特别简单，分为如下几步：</p><ul><li>创建新模块，选择Spring初始化，并配置模块相关基础信息</li><li>选择当前模块需要使用的技术集</li><li>开发控制器类</li><li>运行自动生成的Application类</li></ul><p>知道了 <code>SpringBoot</code> 的开发步骤后，接下来我们进行具体的操作</p><p>1.选择 Spring Initializr ，用来创建 SpringBoot 工程</p><p>2.对 SpringBoot 工程进行相关的设置</p><p>3.选中 Web ，然后勾选 Spring Web</p><p>4.创建 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;id ==&gt; &quot;</span>+id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello , spring boot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.启动服务器</p><p>6.测试</p><h3 id="2-1-SpringBoot如何做到"><a href="#2-1-SpringBoot如何做到" class="headerlink" title="2.1 SpringBoot如何做到"></a>2.1 SpringBoot如何做到</h3><p>先看看 Applicaion 类，该类内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看看 pom.xml 配置文件中的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--指定了一个父工程，父工程中的东西在该工程中可以继承过来使用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itheima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_01_quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--JDK 的版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--该依赖就是我们在创建 SpringBoot 工程勾选的那个 Spring Web 产生的--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--这个是单元测试的依赖，我们现在没有进行单元测试，所以这个依赖现在可以没有--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--这个插件是在打包时需要的，而这里暂时还没有用到--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-SpringBoot工程快速启动"><a href="#2-2-SpringBoot工程快速启动" class="headerlink" title="2.2  SpringBoot工程快速启动"></a>2.2  SpringBoot工程快速启动</h3><p>后端可以将 SpringBoot 工程打成 jar 包，该 jar 包运行不依赖于 Tomcat 和 Idea 这些工具也可以正常运行，只 是这个 jar 包在运行过程中连接和我们自己程序相同的 Mysql 数据库即可。</p><p><strong>打包</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jar -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><h2 id="3-SpringBoot概述"><a href="#3-SpringBoot概述" class="headerlink" title="3.SpringBoot概述"></a>3.SpringBoot概述</h2><h3 id="3-1-起步依赖"><a href="#3-1-起步依赖" class="headerlink" title="3.1 起步依赖"></a>3.1 起步依赖</h3><p>我们使用 <code>Spring Initializr</code>  方式创建的 <code>Maven</code> 工程的的 <code>pom.xml</code> 配置文件中自动生成了很多包含 <code>starter</code> 的依赖，如下图</p><img src="/2023/10/29/SpringBoot1/image-20231029112546170.png" class title="image-20231029112546170"><p><strong>starter</strong></p><ul><li><code>SpringBoot</code> 中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的</li></ul><p><strong>parent</strong></p><ul><li><p>所有 <code>SpringBoot</code> 项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的</p></li><li><p><code>spring-boot-starter-parent</code>（2.5.0）与 <code>spring-boot-starter-parent</code>（2.4.6）共计57处坐标版本不同</p></li></ul><p><strong>实际开发</strong></p><ul><li><p>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供</p><blockquote><p>G：groupid</p><p>A：artifactId</p><p>V：version</p></blockquote></li><li><p>如发生坐标错误，再指定version（要小心版本冲突）</p></li></ul><h3 id="3-2-程序启动"><a href="#3-2-程序启动" class="headerlink" title="3.2 程序启动"></a>3.2 程序启动</h3><p>创建的每一个 SpringBoot 程序时都包含一个类似于下面的类，我们将这个类称作引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01QuickstartApplication</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Springboot01QuickstartApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>SpringBoot</code> 在创建项目时，采用jar的打包方式</p></li><li><p><code>SpringBoot</code> 的引导类是项目的入口，运行 <code>main</code> 方法就可以启动项目</p><p>因为我们在 <code>pom.xml</code> 中配置了 <code>spring-boot-starter-web</code> 依赖，而该依赖通过前面的学习知道它依赖 <code>tomcat</code> ，所以运行 <code>main</code> 方法就可以使用 <code>tomcat</code> 启动咱们的工程。</p></li></ul><h3 id="3-3-切换web服务器"><a href="#3-3-切换web服务器" class="headerlink" title="3.3 切换web服务器"></a>3.3 切换web服务器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时不光要排除 tomcat 服务 器，还要引入 jetty 服务器。在 pom.xml 中因为 jetty 的起步依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4.配置文件"></a>4.配置文件</h2><h3 id="4-1-配置文件格式"><a href="#4-1-配置文件格式" class="headerlink" title="4.1 配置文件格式"></a>4.1 配置文件格式</h3><p><code>SpringBoot</code> 提供了多种属性配置方式</p><ul><li><p><code>application.properties</code></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">server</span>.<span class="hljs-keyword">port</span>=80<br></code></pre></td></tr></table></figure></li><li><p><code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure></li><li><p><code>application.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">82</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>注意：<code>SpringBoot</code> 程序的配置文件名必须是 <code>application</code> ，只是后缀名不同而已。</p></blockquote><h3 id="4-2-三种配合文件的优先级"><a href="#4-2-三种配合文件的优先级" class="headerlink" title="4.2 三种配合文件的优先级"></a>4.2 三种配合文件的优先级</h3><p>从上述的验证结果可以确定三种配置文件的优先级是： application.properties &gt; application.yml &gt; application.yaml</p><h3 id="4-3-yaml配置文件数据读取"><a href="#4-3-yaml配置文件数据读取" class="headerlink" title="4.3 yaml配置文件数据读取"></a>4.3 yaml配置文件数据读取</h3><h4 id="4-3-1-使用-Value注解"><a href="#4-3-1-使用-Value注解" class="headerlink" title="4.3.1 使用 @Value注解"></a>4.3.1 使用 @Value注解</h4><p>使用 @Value(“表达式”) 注解可以从配合文件中读取数据，注解中用于读取属性名引用方式是： ${一级属性名.二级属性名……} 我们可以在 BookController 中使用 @Value 注解读取配合文件数据，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;lesson&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String lesson;<br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer port;<br>    <span class="hljs-meta">@Value(&quot;$&#123;enterprise.subject[0]&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String subject_00;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(lesson);<br>        System.out.println(port);<br>        System.out.println(subject_00);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello , spring boot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2-Environment对象"><a href="#4-3-2-Environment对象" class="headerlink" title="4.3.2 Environment对象"></a>4.3.2 Environment对象</h4><p>上面方式读取到的数据特别零散， SpringBoot 还可以使用 @Autowired 注解注入 Environment 对象的方式读取数据。这 种方式 SpringBoot 会将配置文件中所有的数据封装到 Environment 对象中，如果需要使用哪个数据只需要通过调用 Environment 对象的 getProperty(String name) 方法获取。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Environment env;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(env.getProperty(<span class="hljs-string">&quot;lesson&quot;</span>));<br>        System.out.println(env.getProperty(<span class="hljs-string">&quot;enterprise.name&quot;</span>));<br>        System.out.println(env.getProperty(<span class="hljs-string">&quot;enterprise.subject[0]&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello , spring boot!&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意：这种方式，框架内容大量数据，而在开发中我们很少使用。</span><br></code></pre></td></tr></table></figure><h4 id="4-3-3-自定义对象"><a href="#4-3-3-自定义对象" class="headerlink" title="4.3.3  自定义对象"></a>4.3.3  自定义对象</h4><p><code>SpringBoot</code> 还提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下：</p><ul><li><p>将实体类 <code>bean</code> 的创建交给 <code>Spring</code> 管理。</p><p>在类上添加 <code>@Component</code> 注解</p></li><li><p>使用 <code>@ConfigurationProperties</code> 注解表示加载配置文件</p><p>在该注解中也可以使用 <code>prefix</code> 属性指定只加载指定前缀的数据</p></li><li><p>在 <code>BookController</code> 中进行注入</p></li></ul><h3 id="4-4-多环境配置"><a href="#4-4-多环境配置" class="headerlink" title="4.4 多环境配置"></a>4.4 多环境配置</h3><h4 id="4-4-1-yaml文件"><a href="#4-4-1-yaml文件" class="headerlink" title="4.4.1 yaml文件"></a>4.4.1 yaml文件</h4><p>在 application.yml 中使用 — 来分割不同的配置，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#设置启用的环境</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#开发</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#生产</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#测试</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">82</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>在上面配置中给不同配置起名字的 spring.profiles 配置项已经过时。最新用来起名字的配置项是</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#开发</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h4 id="4-4-2-properties文件"><a href="#4-4-2-properties文件" class="headerlink" title="4.4.2  properties文件"></a>4.4.2  properties文件</h4><p><code>properties</code> 类型的配置文件配置多环境需要定义不同的配置文件</p><ul><li><p><code>application-dev.properties</code> 是开发环境的配置文件。我们在该文件中配置端口号为 <code>80</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">80</span><br></code></pre></td></tr></table></figure></li><li><p><code>application-test.properties</code> 是测试环境的配置文件。我们在该文件中配置端口号为 <code>81</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">81</span><br></code></pre></td></tr></table></figure></li><li><p><code>application-pro.properties</code> 是生产环境的配置文件。我们在该文件中配置端口号为 <code>82</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">82</span><br></code></pre></td></tr></table></figure></li></ul><p><code>SpringBoot</code> 只会默认加载名为 <code>application.properties</code> 的配置文件，所以需要在 <code>application.properties</code> 配置文件中设置启用哪个配置文件，配置如下:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">pro</span><br></code></pre></td></tr></table></figure><h4 id="4-4-3-命令行启动参数设置"><a href="#4-4-3-命令行启动参数设置" class="headerlink" title="4.4.3  命令行启动参数设置"></a>4.4.3  命令行启动参数设置</h4><p>使用 <code>SpringBoot</code> 开发的程序以后都是打成 <code>jar</code> 包，通过 <code>java -jar xxx.jar</code> 的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。</p><p>我们知道 <code>jar</code> 包其实就是一个压缩包，可以解压缩，然后修改配置，最后再打成jar包就可以了。这种方式显然有点麻烦，而 <code>SpringBoot</code> 提供了在运行 <code>jar</code> 时设置开启指定的环境的方式，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java –jar xxx.jar –-spring.profiles.active=test<br></code></pre></td></tr></table></figure><p>那么这种方式能不能临时修改端口号呢？也是可以的，可以通过如下方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java –jar xxx.jar –-server.port=88<br></code></pre></td></tr></table></figure><p>当然也可以同时设置多个配置，比如即指定启用哪个环境配置，又临时指定端口，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java –jar springboot.jar –-server.port=88 –-spring.profiles.active=test<br></code></pre></td></tr></table></figure><p>大家进行测试后就会发现命令行设置的端口号优先级高（也就是使用的是命令行设置的端口号），配置的优先级其实 <code>SpringBoot</code> 官网已经进行了说明，参见 :</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.spring.io<span class="hljs-regexp">/spring-boot/</span>docs<span class="hljs-regexp">/current/</span>reference<span class="hljs-regexp">/html/</span>spring-boot-features.html<span class="hljs-comment">#boot-features-external-config</span><br></code></pre></td></tr></table></figure><p>进入上面网站后会看到如下页面</p><img src="/2023/10/29/SpringBoot1/image-20231029171731942.png" class title="image-20231029171731942"><h3 id="4-5-配置文件分类"><a href="#4-5-配置文件分类" class="headerlink" title="4.5 配置文件分类"></a>4.5 配置文件分类</h3><p><code>SpringBoot</code> 中4级配置文件放置位置：</p><ul><li>1级：classpath：application.yml  </li><li>2级：classpath：config&#x2F;application.yml</li><li>3级：file ：application.yml</li><li>4级：file ：config&#x2F;application.yml</li></ul><h2 id="5-SpringBoot整合junit"><a href="#5-SpringBoot整合junit" class="headerlink" title="5.SpringBoot整合junit"></a>5.SpringBoot整合junit</h2><p>回顾 <code>Spring</code> 整合 <code>junit</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSave</span><span class="hljs-params">()</span>&#123;<br>        bookService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>@RunWith</code> 注解指定运行器，使用 <code>@ContextConfiguration</code> 注解来指定配置类或者配置文件。而 <code>SpringBoot</code> 整合 <code>junit</code> 特别简单，分为以下三步完成</p><ul><li>在测试类上添加 <code>SpringBootTest</code> 注解</li><li>使用 <code>@Autowired</code> 注入要测试的资源</li><li>定义测试方法进行测试</li></ul><p>1.编写测试类</p><p>在 <code>test/java</code> 下创建 <code>com.itheima</code> 包，在该包下创建测试类，将 <code>BookService</code> 注入到该测试类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot07TestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        bookService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;这里的引导类所在包必须是测试类所在包及其子包。</p><p>例如：</p><ul><li>引导类所在包是 <code>com.itheima</code></li><li>测试类所在包是 <code>com.itheima</code></li></ul><p>如果不满足这个要求的话，就需要在使用 <code>@SpringBootTest</code> 注解时，使用 <code>classes</code> 属性指定引导类的字节码对象。如 <code>@SpringBootTest(classes = Springboot07TestApplication.class)</code></p></blockquote><h2 id="6-SpringBoot整合mybatis"><a href="#6-SpringBoot整合mybatis" class="headerlink" title="6.SpringBoot整合mybatis"></a>6.SpringBoot整合mybatis</h2><h3 id="6-1-回顾Spring整合Mybatis"><a href="#6-1-回顾Spring整合Mybatis" class="headerlink" title="6.1  回顾Spring整合Mybatis"></a>6.1  回顾Spring整合Mybatis</h3><p><code>Spring</code> 整合 <code>Mybatis</code> 需要定义很多配置类</p><ul><li><p><code>SpringConfig</code> 配置类</p><ul><li><p>导入 <code>JdbcConfig</code> 配置类</p></li><li><p>导入 <code>MybatisConfig</code> 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@Import(&#123;JdbcConfig.class,MyBatisConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>JdbcConfig</code> 配置类</p></li><li><p>定义数据源（加载properties配置项：driver、url、username、password）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(driver);<br>        ds.setUrl(url);<br>        ds.setUsername(userName);<br>        ds.setPassword(password);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>MybatisConfig</code> 配置类</p><ul><li><p>定义 <code>SqlSessionFactoryBean</code></p></li><li><p>定义映射配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title function_">getMapperScannerConfigurer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">MapperScannerConfigurer</span> <span class="hljs-variable">msc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperScannerConfigurer</span>();<br>    msc.setBasePackage(<span class="hljs-string">&quot;com.itheima.dao&quot;</span>);<br>    <span class="hljs-keyword">return</span> msc;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title function_">getSqlSessionFactoryBean</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>    <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">ssfb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>    ssfb.setTypeAliasesPackage(<span class="hljs-string">&quot;com.itheima.domain&quot;</span>);<br>    ssfb.setDataSource(dataSource);<br>    <span class="hljs-keyword">return</span> ssfb;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-2-SpringBoot整合mybatis"><a href="#6-2-SpringBoot整合mybatis" class="headerlink" title="6.2 SpringBoot整合mybatis"></a>6.2 SpringBoot整合mybatis</h3><p><strong>1.创建模块</strong></p><p>创建新模块，选择 Spring Initializr ，并配置模块相关基础信息</p><p><strong>2.定义实体类</strong></p><p>在 com.itheima.domain 包下定义实体类 Book ，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-keyword">private</span> String description;<br>    <br>    <span class="hljs-comment">//setter and  getter</span><br>    <br>    <span class="hljs-comment">//toString</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.定义dao接口</strong></p><p>在 com.itheima.dao 包下定义 BookDao 接口，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getById</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.定义测试类</strong></p><p>在 test&#x2F;java 下定义包 com.itheima ，在该包下测试类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot08MybatisApplicationTests</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> BookDao bookDao;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetById</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> bookDao.getById(<span class="hljs-number">1</span>);<br>System.out.println(book);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.编写配置</strong></p><p>在 application.yml 配置文件中配置如下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm_db</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p><strong>6.测试</strong></p><p>运行测试方法，我们会看到如下错误信息</p><img src="/2023/10/29/SpringBoot1/image-20231029173105782.png" class title="image-20231029173105782"><p>错误信息显示在 Spring 容器中没有 BookDao 类型的 bean 。为什么会出现这种情况呢？ </p><p>原因是 Mybatis 会扫描接口并创建接口的代码对象交给 Spring 管理，但是现在并没有告诉 Mybatis 哪个是 dao 接口。 而我们要解决这个问题需要在 BookDao 接口上使用 @Mapper ， BookDao 接口改进为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getById</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-使用Druid数据源"><a href="#6-3-使用Druid数据源" class="headerlink" title="6.3 使用Druid数据源"></a>6.3 使用Druid数据源</h3><p>现在我们并没有指定数据源，<code>SpringBoot</code> 有默认的数据源，我们也可以指定使用 <code>Druid</code> 数据源，按照以下步骤实现</p><ul><li><p>导入 <code>Druid</code> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>application.yml</code> 配置文件配置</p><p>可以通过 <code>spring.datasource.type</code> 来配置使用什么数据源。配置文件内容可以改进为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2023/10/26/SpringMVC1/"/>
    <url>/2023/10/26/SpringMVC1/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="1-SpringMVC概述"><a href="#1-SpringMVC概述" class="headerlink" title="1.SpringMVC概述"></a>1.SpringMVC概述</h2><p>后端服务器Servlet拆分成三层，分别是<code>web</code>、<code>service</code>和<code>dao</code></p><ul><li>web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端</li><li>service层主要负责业务逻辑的处理</li><li>dao层主要负责数据的增删改查操作</li></ul><p>servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求</p><p>针对web层进行了优化，采用了MVC设计模式，将其设计为<code>controller</code>、<code>view</code>和<code>Model</code></p><ul><li>controller负责请求和数据的接收，接收后将其转发给service进行业务处理</li><li>service根据需要会调用dao对数据进行增删改查</li><li>dao把数据处理完后将结果交给service,service再交给controller</li><li>controller根据需求组装成Model和View,Model和View组合起来生成页面转发给前端浏览器</li><li>这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作。</li></ul><img src="/2023/10/26/SpringMVC1/image-20231026194017098.png" class title="image-20231026194017098"><ul><li>因为是异步调用，所以后端不需要返回view视图，将其去除</li><li>前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回</li><li>SpringMVC主要负责的就是<ul><li>controller如何接收请求和数据</li><li>如何将请求和数据转发给业务层</li><li>如何将响应数据转换成json发回到前端</li></ul></li></ul><h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2.需求分析"></a>2.需求分析</h2><h3 id="2-1-案例"><a href="#2-1-案例" class="headerlink" title="2.1 案例"></a>2.1 案例</h3><p>1:创建Maven项目</p><p>2.补全目录结构</p><p>3.导入jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;project xmlns=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>  xsi:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;<br>  &lt;modelVersion&gt;<span class="hljs-number">4.0</span><span class="hljs-number">.0</span>&lt;/modelVersion&gt;<br>  &lt;groupId&gt;com.itheima&lt;/groupId&gt;<br>  &lt;artifactId&gt;springmvc_01_quickstart&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">1.0</span>-SNAPSHOT&lt;/version&gt;<br>  &lt;packaging&gt;war&lt;/packaging&gt;<br><br>  &lt;dependencies&gt;<br>    &lt;dependency&gt;<br>      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br>      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br>      &lt;version&gt;<span class="hljs-number">3.1</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>      &lt;scope&gt;provided&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>      &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br>      &lt;version&gt;<span class="hljs-number">5.2</span><span class="hljs-number">.10</span>.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>  &lt;/dependencies&gt;<br><br>  &lt;build&gt;<br>    &lt;plugins&gt;<br>      &lt;plugin&gt;<br>        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;<br>        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">2.1</span>&lt;/version&gt;<br>        &lt;configuration&gt;<br>          &lt;port&gt;<span class="hljs-number">80</span>&lt;/port&gt;<br>          &lt;path&gt;/&lt;/path&gt;<br>        &lt;/configuration&gt;<br>      &lt;/plugin&gt;<br>    &lt;/plugins&gt;<br>  &lt;/build&gt;<br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><p>4.创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.创建Controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user save ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.使用配置类替换web.xml</p><p>将web.xml删除，换成ServletContainersInitConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContainersInitConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-comment">//加载springmvc配置类</span><br>    <span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createServletApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//初始化WebApplicationContext对象</span><br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        <span class="hljs-comment">//加载指定配置类</span><br>        ctx.register(SpringMvcConfig.class);<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br><br>    <span class="hljs-comment">//设置由springmvc控制器处理的请求映射路径</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//加载spring配置类</span><br>    <span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.配置Tomcat环境</p><p>8.启动运行项目</p><p>9.浏览器访问</p><p>10.修改Controller返回值解决上述问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user save ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果方法直接返回字符串，springmvc会把字符串当成页面的名称在项目中进行查找 返回，因为不存在对应返回值名称的页面，所以会报404错误，找不到资源。 而我们其实是想要直接返回的是json数据</p><p>11.设置返回数据为json</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user save ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@Controller</strong></p><table><thead><tr><th>名称</th><th>@Controller</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类定义上方</td></tr><tr><td>作用</td><td>设定SpringMVC的核心控制器bean</td></tr></tbody></table><p><strong>知识点2：@RequestMapping</strong></p><table><thead><tr><th>名称</th><th>@RequestMapping</th></tr></thead><tbody><tr><td>类型</td><td>类注解或方法注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类或方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法请求访问路径</td></tr><tr><td>相关属性</td><td>value(默认)，请求访问路径</td></tr></tbody></table><p><strong>知识点3：@ResponseBody</strong></p><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>类注解或方法注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类或方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法响应内容为当前返回值，无需解析</td></tr></tbody></table><h3 id="2-2-工作流程解析"><a href="#2-2-工作流程解析" class="headerlink" title="2.2 工作流程解析"></a>2.2 工作流程解析</h3><img src="/2023/10/26/SpringMVC1/image-20231027102518165.png" class title="image-20231027102518165"><h4 id="2-2-1-启动服务器初始化过程"><a href="#2-2-1-启动服务器初始化过程" class="headerlink" title="2.2.1 启动服务器初始化过程"></a>2.2.1 启动服务器初始化过程</h4><p>1.服务器启动，执行ServletContainersInitConfig类，初始化web容器 功能类似于以前的web.xml</p><p>2.执行createServletApplicationContext方法，创建了WebApplicationContext对象 该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器</p><p>3.加载SpringMvcConfig配置类</p><img src="/2023/10/26/SpringMVC1/image-20231027103147617.png" class title="image-20231027103147617"><p>4.执行@ComponentScan加载对应的bean.扫描指定包及其子包下所有类上的注解，如Controller类上的@Controller注解</p><p>5.加载UserController，每个@RequestMapping的名称对应一个具体的方法,此时就建立了 &#x2F;save 和 save方法的对应关系</p><img src="/2023/10/26/SpringMVC1/image-20231027103556188.png" class title="image-20231027103556188"><p>6.执行getServletMappings方法，设定SpringMVC拦截请求的路径规则,&#x2F;代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</p><img src="/2023/10/26/SpringMVC1/image-20231027103904092.png" class title="image-20231027103904092"><h4 id="2-2-2-单次请求过程"><a href="#2-2-2-单次请求过程" class="headerlink" title="2.2.2 单次请求过程"></a>2.2.2 单次请求过程</h4><ol><li>发送请求<code>http://localhost/save</code></li><li>web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</li><li>解析请求路径&#x2F;save</li><li>由&#x2F;save匹配执行对应的方法save(）<ul><li>上面的第五步已经将请求路径和方法建立了对应关系，通过&#x2F;save就能找到对应的save方法</li></ul></li><li>执行save()</li><li>检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方</li></ol><h3 id="2-3-bean加载控制"><a href="#2-3-bean加载控制" class="headerlink" title="2.3 bean加载控制"></a>2.3 bean加载控制</h3><ul><li><p>config目录存入的是配置类,写过的配置类有:</p><ul><li>ServletContainersInitConfig</li><li>SpringConfig</li><li>SpringMvcConfig</li><li>JdbcConfig</li><li>MybatisConfig</li></ul></li><li><p>controller目录存放的是SpringMVC的controller类</p></li><li><p>service目录存放的是service接口和实现类</p></li><li><p>dao目录存放的是dao&#x2F;Mapper接口</p></li></ul><p>controller、service和dao这些类都需要被容器管理成bean对象，那么到底是该让SpringMVC加载还是让Spring加载呢?</p><ul><li>SpringMVC加载其相关bean(表现层bean),也就是controller包下的类</li><li>Spring控制的bean<ul><li>业务bean(Service)</li><li>功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)</li></ul></li></ul><p>在SpringMVC的配置类SpringMvcConfig中使用注解@ComponentScan，我们只需要将其扫描范围设 置到controller即可，如</p><img src="/2023/10/26/SpringMVC1/image-20231027110952195.png" class title="image-20231027110952195"><p>在Spring的配置类SpringConfig中使用注解@ComponentScan ,当时扫描的范围中其实是已经包含 了controller，如</p><img src="/2023/10/26/SpringMVC1/image-20231027111007874.png" class title="image-20231027111007874">从包结构来看的话，Spring已经多把SpringMVC的controller类也给扫描到，所以针对这个问题该如何解决，就是咱们接下来要学习的内容。<p><strong>加载Spring控制的bean的时候排除掉SpringMVC控制的bean</strong></p><h4 id="2-3-1-设置bean加载控制"><a href="#2-3-1-设置bean加载控制" class="headerlink" title="2.3.1 设置bean加载控制"></a>2.3.1 设置bean加载控制</h4><p>方式一：修改Spring配置类，设定扫描范围为精准范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式二：修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value=&quot;com.itheima&quot;,</span><br><span class="hljs-meta">    excludeFilters=@ComponentScan.Filter(</span><br><span class="hljs-meta">    type = FilterType.ANNOTATION,</span><br><span class="hljs-meta">        classes = Controller.class</span><br><span class="hljs-meta">    )</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@ComponentScan</strong></p><table><thead><tr><th>名称</th><th>@ComponentScan</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td>相关属性</td><td>excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)<br>includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes)</td></tr></tbody></table><h2 id="3-请求"><a href="#3-请求" class="headerlink" title="3.请求"></a>3.请求</h2><h3 id="3-1-请求映射路径"><a href="#3-1-请求映射路径" class="headerlink" title="3.1 请求映射路径"></a>3.1 请求映射路径</h3><p>1.修改Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/save&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user save ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/user/delete&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user delete ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/save&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book save ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.优化路径配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user save ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/delete&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user delete ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book save ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//当类上和方法上都添加了@RequestMapping注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。</span><br><span class="hljs-comment">//@RequestMapping注解value属性前面加不加/都可以</span><br></code></pre></td></tr></table></figure><h3 id="3-2-请求参数"><a href="#3-2-请求参数" class="headerlink" title="3.2 请求参数"></a>3.2 请求参数</h3><p><strong>GET发送单个参数</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://localhost/commonParam?name=itcast<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/commonParam&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">commonParam</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>GET发送多个参数</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://localhost/commonParam?name=itcast&amp;age=15<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/commonParam&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">commonParam</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>POST发送参数</strong></p><p>发送参数和GET一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/commonParam&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">commonParam</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>POST请求中文乱码</strong></p><p>解决方案:配置过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContainersInitConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//乱码处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;<br>        <span class="hljs-type">CharacterEncodingFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterEncodingFilter</span>();<br>        filter.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>[]&#123;filter&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-五种类型参数传递"><a href="#3-3-五种类型参数传递" class="headerlink" title="3.3 五种类型参数传递"></a>3.3 五种类型参数传递</h3><h4 id="3-3-1-普通参数"><a href="#3-3-1-普通参数" class="headerlink" title="3.3.1  普通参数"></a>3.3.1  普通参数</h4><p>普通参数:url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数</p><img src="/2023/10/26/SpringMVC1/image-20231028103532681.png" class title="image-20231028103532681"><p>如果形参与地址参数名不一致,使用@RequestParam注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/commonParamDifferentName&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">commonParamDifferentName</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String userName , <span class="hljs-type">int</span> age)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 userName ==&gt; &quot;</span>+userName);<br>        System.out.println(<span class="hljs-string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;common param different name&#x27;&#125;&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-POJO数据类型"><a href="#3-3-2-POJO数据类型" class="headerlink" title="3.3.2 POJO数据类型"></a>3.3.2 POJO数据类型</h4><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//setter...getter...略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发送请求和参数:</p><img src="/2023/10/26/SpringMVC1/image-20231028103826255.png" class title="image-20231028103826255"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span><br><span class="hljs-meta">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pojoParam</span><span class="hljs-params">(User user)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;pojo参数传递 user ==&gt; &quot;</span>+user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//POJO参数接收，前端GET和POST发送请求数据的方式不变。</span><br><span class="hljs-comment">//请求参数key的名称要和POJO中属性的名称一致，否则无法封装。</span><br></code></pre></td></tr></table></figure><h4 id="3-3-3-嵌套POJO类型参数"><a href="#3-3-3-嵌套POJO类型参数" class="headerlink" title="3.3.3 嵌套POJO类型参数"></a>3.3.3 嵌套POJO类型参数</h4><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-comment">//setter...getter...略</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">//setter...getter...略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发送请求和参数:</p><img src="/2023/10/26/SpringMVC1/image-20231028104048860.png" class title="image-20231028104048860"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span><br><span class="hljs-meta">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pojoParam</span><span class="hljs-params">(User user)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;pojo参数传递 user ==&gt; &quot;</span>+user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;<br>&#125;<br><span class="hljs-comment">//请求参数key的名称要和POJO中属性的名称一致，否则无法封装</span><br></code></pre></td></tr></table></figure><h4 id="3-3-4-数组类型参数"><a href="#3-3-4-数组类型参数" class="headerlink" title="3.3.4 数组类型参数"></a>3.3.4 数组类型参数</h4><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数</p><p>发送请求和参数:</p><img src="/2023/10/26/SpringMVC1/image-20231028104232169.png" class title="image-20231028104232169"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中</span><br>  <span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span><br>  <span class="hljs-meta">@ResponseBody</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(String[] likes)</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;数组参数传递 likes ==&gt; &quot;</span>+ Arrays.toString(likes));<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-5-集合类型参数"><a href="#3-3-5-集合类型参数" class="headerlink" title="3.3.5  集合类型参数"></a>3.3.5  集合类型参数</h4><p>发送请求和参数:</p><img src="/2023/10/26/SpringMVC1/image-20231028104315040.png" class title="image-20231028104315040"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据</span><br><span class="hljs-meta">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">listParam</span><span class="hljs-params">(List&lt;String&gt; likes)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;集合参数传递 likes ==&gt; &quot;</span>+ likes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>错误的原因是:SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数 据封装到对象中，但是List是一个接口无法创建对象，所以报错</p><p>解决方案是:使用@RequestParam注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据</span><br><span class="hljs-meta">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">listParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;集合参数传递 likes ==&gt; &quot;</span>+ likes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@RequestParam</strong></p><table><thead><tr><th>名称</th><th>@RequestParam</th></tr></thead><tbody><tr><td>类型</td><td>形参注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>绑定请求参数与处理器方法形参间的关系</td></tr><tr><td>相关参数</td><td>required：是否为必传参数 <br>defaultValue：参数默认值</td></tr></tbody></table><h3 id="3-4-响应JSON数据"><a href="#3-4-响应JSON数据" class="headerlink" title="3.4 响应JSON数据"></a>3.4 响应JSON数据</h3><h4 id="3-4-1-JSON普通数组"><a href="#3-4-1-JSON普通数组" class="headerlink" title="3.4.1 JSON普通数组"></a>3.4.1 JSON普通数组</h4><p>1.pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.PostMan发送JSON数据</p><img src="/2023/10/26/SpringMVC1/image-20231028105843339.png" class title="image-20231028105843339"><p>3.开启SpringMVC注解支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span><br><span class="hljs-comment">//开启json数据类型自动转换</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>4:参数前添加@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span><br><span class="hljs-meta">@RequestMapping(&quot;/listParamForJson&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">listParamForJson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;list common(json)参数传递 list ==&gt; &quot;</span>+likes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤5:启动运行程序</p><h4 id="3-4-2-JSON对象数据"><a href="#3-4-2-JSON对象数据" class="headerlink" title="3.4.2 JSON对象数据"></a>3.4.2 JSON对象数据</h4><p>请求和数据的发送:</p><img src="/2023/10/26/SpringMVC1/image-20231028112017358.png" class title="image-20231028112017358"><p>后端接收数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/pojoParamForJson&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pojoParamForJson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;pojo(json)参数传递 user ==&gt; &quot;</span>+user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-3-JSON对象数组"><a href="#3-4-3-JSON对象数组" class="headerlink" title="3.4.3 JSON对象数组"></a>3.4.3 JSON对象数组</h4><img src="/2023/10/26/SpringMVC1/image-20231029093415148.png" class title="image-20231029093415148"><p>后端接收数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/listPojoParamForJson&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">listPojoParamForJson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;User&gt; list)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;list pojo(json)参数传递 list ==&gt; &quot;</span>+list);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@EnableWebMvc</strong></p><table><thead><tr><th>名称</th><th>@EnableWebMvc</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;配置类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC配置类定义上方</td></tr><tr><td>作用</td><td>开启SpringMVC多项辅助功能</td></tr></tbody></table><p><strong>知识点2：@RequestBody</strong></p><table><thead><tr><th>名称</th><th>@RequestBody</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;形参注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</td></tr></tbody></table><p><strong>@RequestBody与@RequestParam区别</strong></p><ul><li><p>区别</p><ul><li>@RequestParam用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li>@RequestBody用于接收json数据【application&#x2F;json】</li></ul></li><li><p>应用</p><ul><li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li></ul></li></ul><h3 id="3-5-日期类型参数传递"><a href="#3-5-日期类型参数传递" class="headerlink" title="3.5 日期类型参数传递"></a>3.5 日期类型参数传递</h3><p>1.编写方法接收日期数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dataParam</span><span class="hljs-params">(Date date)</span><br>    System.out.println(<span class="hljs-string">&quot;参数传递 date ==&gt; &quot;</span>+date);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.启动Tomcat服务器</p><p>3.使用PostMan发送请求</p><p>4.查看控制台</p><p>5.更换日期格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dataParam</span><span class="hljs-params">(Date date,Date date1)</span><br>    System.out.println(<span class="hljs-string">&quot;参数传递 date ==&gt; &quot;</span>+date);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用PostMan发送请求，携带两个不同的日期格式， <code>http://localhost/dataParam?date=2088/08/08&amp;date1=2088-08-08</code></p><p>发送请求和数据后，页面会报400，控制台会报出一个错误，错误的原因是在将2088-08-08转换成日期类型的时候失败了，原因是 SpringMVC默认支持的字符串转日期的格式为yyyy&#x2F;MM&#x2F;dd ,而我们现在传递的不符合其默认格式， SpringMVC就无法进行格式转换，所以报错</p><p>解决方案也比较简单，需要使用@DateTimeFormat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dataParam</span><span class="hljs-params">(Date date,</span><br><span class="hljs-params">                        <span class="hljs-meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date1)</span><br>    System.out.println(<span class="hljs-string">&quot;参数传递 date ==&gt; &quot;</span>+date);<br>System.out.println(<span class="hljs-string">&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;</span>+date1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.携带时间的日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dataParam&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dataParam</span><span class="hljs-params">(Date date,</span><br><span class="hljs-params">                        <span class="hljs-meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date1,</span><br><span class="hljs-params">                        <span class="hljs-meta">@DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date2)</span><br>    System.out.println(<span class="hljs-string">&quot;参数传递 date ==&gt; &quot;</span>+date);<br>System.out.println(<span class="hljs-string">&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;</span>+date1);<br>System.out.println(<span class="hljs-string">&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;</span>+date2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@DateTimeFormat</strong></p><table><thead><tr><th>名称</th><th>@DateTimeFormat</th></tr></thead><tbody><tr><td>类型</td><td>形参注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参前面</td></tr><tr><td>作用</td><td>设定日期时间型数据格式</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><h2 id="4-响应"><a href="#4-响应" class="headerlink" title="4.响应"></a>4.响应</h2><h3 id="4-1-响应页面"><a href="#4-1-响应页面" class="headerlink" title="4.1 响应页面"></a>4.1 响应页面</h3><p>1.设置返回页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/toJumpPage&quot;)</span><br>    <span class="hljs-comment">//注意</span><br>    <span class="hljs-comment">//1.此处不能添加@ResponseBody,如果加了该注入，会直接将page.jsp当字符串返回前端</span><br>    <span class="hljs-comment">//2.方法需要返回String</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toJumpPage</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;跳转页面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;page.jsp&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>2.启动程序测试</p><h3 id="4-2-返回文本数据"><a href="#4-2-返回文本数据" class="headerlink" title="4.2 返回文本数据"></a>4.2 返回文本数据</h3><p>1.设置返回文本内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>   <span class="hljs-meta">@RequestMapping(&quot;/toText&quot;)</span><br><span class="hljs-comment">//注意此处该注解就不能省略，如果省略了,会把response text当前页面名称去查找，如果没有回报404错误</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toText</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;返回纯文本数据&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;response text&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>2.启动程序测试</p><h3 id="4-3-响应JSON数据"><a href="#4-3-响应JSON数据" class="headerlink" title="4.3 响应JSON数据"></a>4.3 响应JSON数据</h3><p><strong>响应JSON数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">toJsonPOJO</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;返回json对象数据&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        user.setAge(<span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖**@ResponseBody<strong>注解和</strong>@EnableWebMvc**注解</p><p><strong>响应POJO集合对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/toJsonList&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">toJsonList</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;返回json集合数据&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user1.setName(<span class="hljs-string">&quot;传智播客&quot;</span>);<br>        user1.setAge(<span class="hljs-number">15</span>);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user2.setName(<span class="hljs-string">&quot;黑马程序员&quot;</span>);<br>        user2.setAge(<span class="hljs-number">12</span>);<br><br>        List&lt;User&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;User&gt;();<br>        userList.add(user1);<br>        userList.add(user2);<br><br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@ResponseBody</strong></p><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>方法\类注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法定义上方和控制类上</td></tr><tr><td>作用</td><td>设置当前控制器返回值作为响应体,<br>写在类上，该类的所有方法都有该注解功能</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><h2 id="5-Rest风格"><a href="#5-Rest风格" class="headerlink" title="5. Rest风格"></a>5. Rest风格</h2><h3 id="5-1-REST简介"><a href="#5-1-REST简介" class="headerlink" title="5.1 REST简介"></a>5.1 REST简介</h3><p>REST（Representational State Transfer），表现形式状态转换,它是一种软件架构风格 当我们想表示一个网络资源的时候，可以使用两种方式:</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li></ul></li></ul><p>REST的<strong>优点</strong>有:</p><ul><li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作</p><ul><li><code>http://localhost/users</code>查询全部用户信息 GET（查询）</li><li><code>http://localhost/users/1</code>  查询指定用户信息 GET（查询）</li><li><code>http://localhost/users</code>    添加用户信息    POST（新增&#x2F;保存）</li><li><code>http://localhost/users</code>    修改用户信息    PUT（修改&#x2F;更新）</li><li><code>http://localhost/users/1</code>  删除用户信息    DELETE（删除）</li></ul><p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p><p>按照不同的请求方式代表不同的操作类型。</p><ul><li>发送GET请求是用来做查询</li><li>发送POST请求是用来做新增</li><li>发送PUT请求是用来做修改</li><li>发送DELETE请求是用来做删除</li></ul><p>清楚了什么是REST风格后，我们后期会经常提到一个概念叫RESTful，那什么又是RESTful呢? <strong>根据REST风格对资源进行访问称为RESTful</strong>。</p><h3 id="5-2-案例"><a href="#5-2-案例" class="headerlink" title="5.2 案例"></a>5.2 案例</h3><p><strong>1.新增</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><span class="hljs-comment">//设置当前请求方法为POST，表示REST风格中的添加操作</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;user save...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 POST: <code>http://localhost/users</code></li></ul></li><li><p>使用method属性限定该方法的访问方式为<code>POST</code></p><ul><li>如果发送的不是POST请求，比如发送GET请求，则会报错</li></ul></li></ul><img src="/2023/10/26/SpringMVC1/image-20231029102033658.png" class title="image-20231029102033658"><p><strong>2.删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.DELETE)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;user delete...&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将请求路径更改为<code>/users</code><ul><li>访问该方法使用 DELETE: <code>http://localhost/users</code></li></ul></li></ul><p>访问成功，但是删除方法没有携带所要删除数据的id,所以针对RESTful的开发，如何携带数据参数?</p><p><strong>传递路径参数</strong></p><p>前端发送请求的时候使用:<code>http://localhost/users/1</code>,路径中的<code>1</code>就是我们想要传递的参数。</p><p>后端获取参数，需要做如下修改:</p><ul><li>修改@RequestMapping的value属性，将其中修改为<code>/users/&#123;id&#125;</code>，目的是和路径匹配</li><li>在方法的形参前添加@PathVariable注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;user delete...&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/10/26/SpringMVC1/image-20231029102221961.png" class title="image-20231029102221961"><p>前端发送请求的时候使用: <code>http://localhost/users/1/tom</code> ,路径中的1和tom就是我们想要传递的 两个参数。 后端获取参数，需要做如下修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/users/&#123;id&#125;/&#123;name&#125;&quot;,method = RequestMethod.DELETE)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id,<span class="hljs-meta">@PathVariable</span> String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;user delete...&quot;</span> + id+<span class="hljs-string">&quot;,&quot;</span>+name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//设置当前请求方法为PUT，表示REST风格中的修改操作</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.PUT)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;user update...&quot;</span> + user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user update&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 PUT: <code>http://localhost/users</code></li></ul></li><li><p>访问并携带参数:</p></li></ul><img src="/2023/10/26/SpringMVC1/image-20231029102442207.png" class title="image-20231029102442207"><p>4.查询</p><p><strong>根据ID查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//设置当前请求方法为GET，表示REST风格中的查询操作</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot; ,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user getById...&quot;</span>+id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user getById&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 GET: <code>http://localhost/users/666</code></li></ul><p><strong>查询所有</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//设置当前请求方法为GET，表示REST风格中的查询操作</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/users&quot; ,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;user getAll...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;user getAll&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将请求路径更改为<code>/users</code></p><ul><li>访问该方法使用 GET: <code>http://localhost/users</code></li></ul><p><strong>小结</strong></p><p>(1)设定Http请求动作(动词)</p><p>@RequestMapping(value&#x3D;””,<strong>method</strong> &#x3D; RequestMethod.<strong>POST|GET|PUT|DELETE</strong>)</p><p>(2)设定请求参数(路径变量)</p><p>@RequestMapping(value&#x3D;”&#x2F;users&#x2F;<strong>{id}</strong>“,method &#x3D; RequestMethod.DELETE)</p><p>@ReponseBody</p><p>public String delete(<strong>@PathVariable</strong> Integer <strong>id</strong>){</p><p>}</p><p><strong>知识点1：@PathVariable</strong></p><table><thead><tr><th>名称</th><th>@PathVariable</th></tr></thead><tbody><tr><td>类型</td><td>形参注解</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</td></tr></tbody></table><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="5-3-RESTful快速开发"><a href="#5-3-RESTful快速开发" class="headerlink" title="5.3 RESTful快速开发"></a>5.3 RESTful快速开发</h3><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">将<span class="hljs-meta">@RequestMapping</span>提到类上面，用来定义所有方法共同的访问路径。<br></code></pre></td></tr></table></figure><p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">使用<span class="hljs-meta">@GetMapping</span> <span class="hljs-meta">@PostMapping</span> <span class="hljs-meta">@PutMapping</span> <span class="hljs-meta">@DeleteMapping</span>代替<br></code></pre></td></tr></table></figure><p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>将ResponseBody提到类上面，让所有的方法都有<span class="hljs-meta">@ResponseBody</span>的功能<br><span class="hljs-number">2.</span>使用<span class="hljs-meta">@RestController</span>注解替换<span class="hljs-meta">@Controller</span>与<span class="hljs-meta">@ResponseBody</span>注解，简化书写<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//@Controller + ReponseBody</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <br><span class="hljs-comment">//@RequestMapping(method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book save...&quot;</span> + book);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book delete...&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//@RequestMapping(method = RequestMethod.PUT)</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book update...&quot;</span> + book);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book getById...&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//@RequestMapping(method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book getAll...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@RestController</strong></p><table><thead><tr><th>名称</th><th>@RestController</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器类定义上方</td></tr><tr><td>作用</td><td>设置当前控制器类为RESTful风格，<br>等同于@Controller与@ResponseBody两个注解组合功能</td></tr></tbody></table><p><strong>知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping</strong></p><table><thead><tr><th>名称</th><th>@GetMapping @PostMapping @PutMapping @DeleteMapping</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br>例如@GetMapping对应GET请求</td></tr><tr><td>相关属性</td><td>value（默认）：请求访问路径</td></tr></tbody></table><h3 id="5-4-RESTful案例"><a href="#5-4-RESTful案例" class="headerlink" title="5.4 RESTful案例"></a>5.4 RESTful案例</h3><p>需求一:图片列表查询，从后台返回数据，将数据展示在页面上</p><img src="/2023/10/26/SpringMVC1/image-20231029104047701.png" class title="image-20231029104047701"><p>需求二:新增图片，将新增图书的数据传递到后台，并在控制台打印</p><img src="/2023/10/26/SpringMVC1/image-20231029104106494.png" class title="image-20231029104106494"><p>步骤分析:</p><blockquote><p>1.搭建项目导入jar包</p><p>2.编写Controller类，提供两个方法，一个用来做列表查询，一个用来做新增</p><p>3.在方法上使用RESTful进行路径设置</p><p>4.完成请求、参数的接收和结果的响应</p><p>5.使用PostMan进行测试</p><p>6.将前端页面拷贝到项目中</p><p>7.页面发送ajax请求</p><p>8.完成页面数据的展示</p></blockquote><p>1.编写Controller类并使用RESTful进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book save ==&gt; &quot;</span>+ book);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;module&#x27;:&#x27;book save success&#x27;&#125;&quot;</span>;<br>    &#125;<br><br> <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book getAll is running ...&quot;</span>);<br>        List&lt;Book&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Book&gt;();<br><br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>        book1.setType(<span class="hljs-string">&quot;计算机&quot;</span>);<br>        book1.setName(<span class="hljs-string">&quot;SpringMVC入门教程&quot;</span>);<br>        book1.setDescription(<span class="hljs-string">&quot;小试牛刀&quot;</span>);<br>        bookList.add(book1);<br><br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>        book2.setType(<span class="hljs-string">&quot;计算机&quot;</span>);<br>        book2.setName(<span class="hljs-string">&quot;SpringMVC实战教程&quot;</span>);<br>        book2.setDescription(<span class="hljs-string">&quot;一代宗师&quot;</span>);<br>        bookList.add(book2);<br><br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>        book3.setType(<span class="hljs-string">&quot;计算机丛书&quot;</span>);<br>        book3.setName(<span class="hljs-string">&quot;SpringMVC实战教程进阶&quot;</span>);<br>        book3.setDescription(<span class="hljs-string">&quot;一代宗师呕心创作&quot;</span>);<br>        bookList.add(book3);<br><br>        <span class="hljs-keyword">return</span> bookList;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2.使用PostMan进行测试</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP</title>
    <link href="/2023/10/25/Spring-AOP/"/>
    <url>/2023/10/25/Spring-AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-AOP概念"><a href="#1-AOP概念" class="headerlink" title="1.AOP概念"></a>1.AOP概念</h2><p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程 序结构。 </p><p>OOP(Object Oriented Programming)面向对象编程</p><p>**作用:**在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。</p><p><img src="/Spring3/image-20231025161203465.png" alt="image-20231025161203465"></p><h3 id="1-1-案例分析"><a href="#1-1-案例分析" class="headerlink" title="1.1 案例分析"></a>1.1 案例分析</h3><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.定义接口与实现类</p><p>3.定义通知类和通知</p><p>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(System.currentTimeMillis());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//类名和方法名没有要求，可以任意</span><br></code></pre></td></tr></table></figure><p>4.定义切入点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(System.currentTimeMillis());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑</span><br></code></pre></td></tr></table></figure><p>5.制作切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(System.currentTimeMillis());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行</span><br></code></pre></td></tr></table></figure><p>6.将通知类配给容器并标识其为切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(System.currentTimeMillis());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.开启注解格式AOP功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.运行程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(BookDao.class);<br>        bookDao.update();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@EnableAspectJAutoProxy</strong>  </p><table><thead><tr><th>名称</th><th>@EnableAspectJAutoProxy</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>开启注解格式AOP功能</td></tr></tbody></table><p><strong>知识点2：@Aspect</strong></p><table><thead><tr><th>名称</th><th>@Aspect</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>切面类定义上方</td></tr><tr><td>作用</td><td>设置当前类为AOP切面类</td></tr></tbody></table><p><strong>知识点3：@Pointcut</strong>   </p><table><thead><tr><th>名称</th><th>@Pointcut</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>切入点方法定义上方</td></tr><tr><td>作用</td><td>设置切入点方法</td></tr><tr><td>属性</td><td>value（默认）：切入点表达式</td></tr></tbody></table><p><strong>知识点4：@Before</strong></p><table><thead><tr><th>名称</th><th>@Before</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><h3 id="1-2-AOP工作流程"><a href="#1-2-AOP工作流程" class="headerlink" title="1.2 AOP工作流程"></a>1.2 AOP工作流程</h3><p>1.Spring容器启动</p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li><li>注意此时bean对象还没有创建成功</li></ul><p>2.读取所有切面配置中的切入点</p><p><img src="/Spring3/image-20231025163929112.png" alt="image-20231025163929112"></p><p>上面这个例子中有两个切入点的配置，但是第一个ptx()并没有被使用，所以不会被读取</p><p>3.初始化bean</p><p>判定bean对应的类中的方法是否匹配到任意切入点</p><p><img src="/Spring3/image-20231025164231240.png" alt="image-20231025164231240"></p><p>4.获取bean执行方法</p><p>获取的bean是原始对象时，调用方法并执行，完成操作 </p><p>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</p><h3 id="1-3-AOP核心概念"><a href="#1-3-AOP核心概念" class="headerlink" title="1.3 AOP核心概念"></a>1.3 AOP核心概念</h3><p>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终 工作的 </p><p>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</p><h2 id="2-AOP配置管理"><a href="#2-AOP配置管理" class="headerlink" title="2.AOP配置管理"></a>2.AOP配置管理</h2><h3 id="2-1-AOP切入点表达式"><a href="#2-1-AOP切入点表达式" class="headerlink" title="2.1 AOP切入点表达式"></a>2.1 AOP切入点表达式</h3><p><img src="/Spring3/image-20231025164529924.png" alt="image-20231025164529924"></p><p>切入点:要进行增强的方法 </p><p>切入点表达式:要进行增强的方法的描述方式</p><p>切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<span class="hljs-keyword">public</span> User com.itheima.service.UserService.findById(<span class="hljs-type">int</span>))<br><span class="hljs-comment">//execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</span><br><span class="hljs-comment">//public:访问修饰符,还可以是public，private等，可以省略</span><br><span class="hljs-comment">//User：返回值，写返回值类型</span><br><span class="hljs-comment">//com.itheima.service：包名，多级包使用点连接</span><br><span class="hljs-comment">//UserService:类/接口名称</span><br><span class="hljs-comment">//findById：方法名</span><br><span class="hljs-comment">//int:参数，直接写参数的类型，多个类型用逗号隔开</span><br><span class="hljs-comment">//异常名：方法定义中抛出指定异常，可以省略</span><br></code></pre></td></tr></table></figure><h3 id="2-2-通配符"><a href="#2-2-通配符" class="headerlink" title="2.2 通配符"></a>2.2 通配符</h3><ul><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">execution（<span class="hljs-keyword">public</span> * com.itheima.*.UserService.find*(*))<br></code></pre></td></tr></table></figure><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的<strong>带有一个参数</strong>的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">execution（public <span class="hljs-keyword">User</span> <span class="hljs-title">com</span>..UserService.findById(..))<br></code></pre></td></tr></table></figure><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* *..*Service+.*(..)</span></span>)<br></code></pre></td></tr></table></figure><p>这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com.itheima.*.*Service.find*(..))<br>将项目中所有业务层方法的以find开头的方法匹配<br>execution(* com.itheima.*.*Service.save*(..))<br>将项目中所有业务层方法的以save开头的方法匹配<br></code></pre></td></tr></table></figure><h3 id="2-3-AOP通知类型"><a href="#2-3-AOP通知类型" class="headerlink" title="2.3 AOP通知类型"></a>2.3 AOP通知类型</h3><ul><li>前置通知</li><li>后置通知</li><li><strong>环绕通知(重点)</strong></li><li>返回后通知(了解)</li><li>抛出异常后通知(了解)</li></ul><p><img src="/Spring3/image-20231025165337684.png" alt="image-20231025165337684"></p><h4 id="2-3-1-前置通知"><a href="#2-3-1-前置通知" class="headerlink" title="2.3.1 前置通知"></a>2.3.1 前置通知</h4><p>修改MyAdvice,在before方法上添加<code>@Before注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-comment">//此处也可以写成 @Before(&quot;MyAdvice.pt()&quot;),不建议</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;before advice ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-后置通知"><a href="#2-3-2-后置通知" class="headerlink" title="2.3.2 后置通知"></a>2.3.2 后置通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;before advice ...&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;after advice ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-环绕通知"><a href="#2-3-3-环绕通知" class="headerlink" title="2.3.3 环绕通知"></a>2.3.3 环绕通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;around before advice ...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;around after advice ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果中，通知的内容打印出来，但是原始方法的内容却没有被执行。</p><p><img src="/Spring3/image-20231025165621527.png" alt="image-20231025165621527"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt2</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;pt2()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundSelect</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;around before advice ...&quot;</span>);<br>        <span class="hljs-comment">//表示对原始操作的调用</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;around after advice ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-4-返回后通知"><a href="#2-3-4-返回后通知" class="headerlink" title="2.3.4 返回后通知"></a>2.3.4 返回后通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt2</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(&quot;pt2()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterReturning advice ...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//返回后通知是需要在原始方法select正常执行后才会被执行，如果select()方法执行的过程中出现了异常，那么返回后通知是不会被执行。后置通知是不管原始方法有没有抛出异常都会被执行。</span><br></code></pre></td></tr></table></figure><h4 id="2-3-5-异常后通知"><a href="#2-3-5-异常后通知" class="headerlink" title="2.3.5 异常后通知"></a>2.3.5 异常后通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt2</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(&quot;pt2()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterThrowing advice ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Spring3/image-20231025170349049.png" alt="image-20231025170349049"></p><h3 id="2-3-业务层接口执行效率"><a href="#2-3-业务层接口执行效率" class="headerlink" title="2.3 业务层接口执行效率"></a>2.3 业务层接口执行效率</h3><p>**需求:**任意业务层接口执行均可显示其执行效率（执行时长）</p><p>具体实现的思路: </p><p>(1) 开始执行方法之前记录一个时间 </p><p>(2) 执行方法</p><p>(3) 执行完方法之后记录一个时间 </p><p>(4) 用后一个时间减去前一个时间的差值，就是我们需要的结果</p><p>在方法执行的前后添加业务，经过分析我们将采用<strong>环绕通知</strong>。</p><h4 id="2-3-1-功能开发"><a href="#2-3-1-功能开发" class="headerlink" title="2.3.1 功能开发"></a>2.3.1 功能开发</h4><p>1.开启SpringAOP的注解功能</p><p>在Spring的主配置文件SpringConfig类中添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><br></code></pre></td></tr></table></figure><p>2.创建AOP的通知类</p><p>该类要被Spring管理，需要添加@Component </p><p>要标识该类是一个AOP的切面类，需要添加@Aspect </p><p>配置切入点表达式，需要添加一个方法，并添加@Pointcut</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectAdvice</span> &#123;<br>    <span class="hljs-comment">//配置业务层的所有方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runSpeed</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>3.添加环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectAdvice</span> &#123;<br>    <span class="hljs-comment">//配置业务层的所有方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span><br>    <span class="hljs-meta">@Around(&quot;servicePt()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">runSpeed</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span>&#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>4.完成核心业务，记录万次执行的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectAdvice</span> &#123;<br>    <span class="hljs-comment">//配置业务层的所有方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span><br>    <span class="hljs-meta">@Around(&quot;servicePt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runSpeed</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span>&#123;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>           pjp.proceed();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;业务层接口万次执行时间: &quot;</span>+(end-start)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>5.运行单元测试类</p><p>6.程序优化</p><p>目前程序所面临的问题是，多个方法一起执行测试的时候，控制台都打印的是: 业务层接口万次执行时间:xxxms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectAdvice</span> &#123;<br>    <span class="hljs-comment">//配置业务层的所有方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span><br>    <span class="hljs-meta">@Around(&quot;servicePt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runSpeed</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span>&#123;<br>        <span class="hljs-comment">//获取执行签名信息</span><br>        <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> pjp.getSignature();<br>        <span class="hljs-comment">//通过签名获取执行操作名称(接口名)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> signature.getDeclaringTypeName();<br>        <span class="hljs-comment">//通过签名获取执行操作名称(方法名)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> signature.getName();<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>           pjp.proceed();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;万次执行：&quot;</span>+ className+<span class="hljs-string">&quot;.&quot;</span>+methodName+<span class="hljs-string">&quot;----&gt;&quot;</span> +(end-start) + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>7.运行单元测试类</p><h3 id="2-4-AOP通知获取数据"><a href="#2-4-AOP通知获取数据" class="headerlink" title="2.4 AOP通知获取数据"></a>2.4 AOP通知获取数据</h3><h4 id="2-4-1-获取参数"><a href="#2-4-1-获取参数" class="headerlink" title="2.4.1 获取参数"></a>2.4.1 获取参数</h4><p><strong>非环绕通知获取方式</strong></p><p>在方法上添加JoinPoint,通过JoinPoint来获取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint jp)</span> <br>        Object[] args = jp.getArgs();<br>        System.out.println(Arrays.toString(args));<br>        System.out.println(<span class="hljs-string">&quot;before advice ...&quot;</span> );<br>    &#125;<br><span class="hljs-comment">//...其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>环绕通知获取方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span><span class="hljs-keyword">throws</span> Throwable &#123;<br>        Object[] args = pjp.getArgs();<br>        System.out.println(Arrays.toString(args));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-comment">//其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>pjp.proceed()方法是有两个构造方法，分别是</p><p><img src="/Spring3/image-20231025193634030.png" alt="image-20231025193634030"></p><p>调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数 所以调用这两个方法的任意一个都可以完成功能 但是当需要修改原始方法的参数时，就只能采用带有参数的方法,如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>        Object[] args = pjp.getArgs();<br>        System.out.println(Arrays.toString(args));<br>        args[<span class="hljs-number">0</span>] = <span class="hljs-number">666</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed(args);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-comment">//其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-获取返回值"><a href="#2-4-2-获取返回值" class="headerlink" title="2.4.2 获取返回值"></a>2.4.2 获取返回值</h4><p>对于返回值，只有返回后AfterReturing和环绕Around这两个通知类型可以获取</p><p><strong>环绕通知获取返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>        Object[] args = pjp.getArgs();<br>        System.out.println(Arrays.toString(args));<br>        args[<span class="hljs-number">0</span>] = <span class="hljs-number">666</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed(args);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-comment">//其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>返回后通知获取返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object ret)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterReturning advice ...&quot;</span>+ret);<br>    &#125;<br><span class="hljs-comment">//其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Spring3/image-20231025210502884.png" alt="image-20231025210502884"></p><p><img src="/Spring3/image-20231025210508557.png" alt="image-20231025210508557"></p><h4 id="2-4-3-获取异常"><a href="#2-4-3-获取异常" class="headerlink" title="2.4.3 获取异常"></a>2.4.3 获取异常</h4><p>对于获取抛出的异常，只有抛出异常后AfterThrowing和环绕Around这两个通知类型可以获取</p><p><strong>环绕通知获取异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span>&#123;<br>        Object[] args = pjp.getArgs();<br>        System.out.println(Arrays.toString(args));<br>        args[<span class="hljs-number">0</span>] = <span class="hljs-number">666</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            ret = pjp.proceed(args);<br>        &#125;<span class="hljs-keyword">catch</span>(Throwable throwable)&#123;<br>            t.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-comment">//其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抛出异常后通知获取异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterThrowing advice ...&quot;</span>+t);<br>    &#125;<br><span class="hljs-comment">//其他的略</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-百度网盘密码数据兼容处理"><a href="#2-5-百度网盘密码数据兼容处理" class="headerlink" title="2.5 百度网盘密码数据兼容处理"></a>2.5 百度网盘密码数据兼容处理</h3><p>需求: 对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理</p><p>1.开启SpringAOP的注解功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.编写通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>3.添加环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;DataAdvice.servicePt()&quot;)</span><br>    <span class="hljs-comment">// @Around(&quot;servicePt()&quot;)这两种写法都对</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">trimStr</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>4.完成核心业务，处理参数中的空格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePt</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;DataAdvice.servicePt()&quot;)</span><br>    <span class="hljs-comment">// @Around(&quot;servicePt()&quot;)这两种写法都对</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">trimStr</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//获取原始方法的参数</span><br>        Object[] args = pjp.getArgs();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            <span class="hljs-comment">//判断参数是不是字符串</span><br>            <span class="hljs-keyword">if</span>(args[i].getClass().equals(String.class))&#123;<br>                args[i] = args[i].toString().trim();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将修改后的参数传入到原始方法的执行中</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> pjp.proceed(args);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>5.运行程序</p><p>6.优化测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcesDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResourcesDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readResources</span><span class="hljs-params">(String url, String password)</span> &#123;<br>        System.out.println(password.length());<br>        <span class="hljs-comment">//模拟校验</span><br>        <span class="hljs-keyword">return</span> password.equals(<span class="hljs-string">&quot;root&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-AOP事务管理"><a href="#3-AOP事务管理" class="headerlink" title="3.AOP事务管理"></a>3.AOP事务管理</h2><p>事务作用：在数据层保障一系列的数据库操作同成功同失败 </p><p>Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</p><h3 id="3-1-案例分析"><a href="#3-1-案例分析" class="headerlink" title="3.1 案例分析"></a>3.1 案例分析</h3><p>需求: 实现任意两个账户间转账操作 </p><p>需求微缩: A账户减钱，B账户加钱</p><p>为了实现上述的业务需求，我们可以按照下面步骤来实现下: </p><p>①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） </p><p>②：业务层提供转账操作（transfer），调用减钱与加钱的操作 </p><p>③：提供2个账号和操作金额执行转账操作 </p><p>④：基于Spring整合MyBatis环境搭建上述操作</p><p>1.准备数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database spring_db <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br>use spring_db;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tbl_account(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">35</span>),<br>    money <span class="hljs-keyword">double</span><br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_account <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tbl_account <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>2.创建项目导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.根据表创建模型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Double money;<br><span class="hljs-comment">//setter...getter...toString...方法略    </span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.创建Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountDao</span> &#123;<br><br>    <span class="hljs-meta">@Update(&quot;update tbl_account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">inMoney</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;money&quot;)</span> Double money)</span>;<br><br>    <span class="hljs-meta">@Update(&quot;update tbl_account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">outMoney</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;money&quot;)</span> Double money)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.创建Service接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转账操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 传出方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in 转入方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money 金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> ;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> &#123;<br>        accountDao.outMoney(out,money);<br>        accountDao.inMoney(in,money);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>6.添加jdbc.properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/spring_db?useSSL=false</span><br>jdbc.username=root<br>jdbc.password=root<br></code></pre></td></tr></table></figure><p>7.创建JdbcConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(driver);<br>        ds.setUrl(url);<br>        ds.setUsername(userName);<br>        ds.setPassword(password);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.创建MybatisConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">ssfb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>        ssfb.setTypeAliasesPackage(<span class="hljs-string">&quot;com.itheima.domain&quot;</span>);<br>        ssfb.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> ssfb;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title function_">mapperScannerConfigurer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MapperScannerConfigurer</span> <span class="hljs-variable">msc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperScannerConfigurer</span>();<br>        msc.setBasePackage(<span class="hljs-string">&quot;com.itheima.dao&quot;</span>);<br>        <span class="hljs-keyword">return</span> msc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>9.创建SpringConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>10.编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountService accountService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransfer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        accountService.transfer(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-string">&quot;Jerry&quot;</span>,<span class="hljs-number">100D</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-事务管理"><a href="#3-2-事务管理" class="headerlink" title="3.2 事务管理"></a>3.2 事务管理</h3><p>当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管 理就是用来解决这类问题的</p><p>1.在需要被事务管理的方法上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转账操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 传出方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in 转入方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money 金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//配置当前接口方法具有事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> ;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br><span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> &#123;<br>        accountDao.outMoney(out,money);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>        accountDao.inMoney(in,money);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//@Transactional可以写在接口类上、接口方法上、实现类上和实现类方法上</span><br><span class="hljs-comment">//写在接口类上，该接口的所有实现类的所有方法都会有事务</span><br><span class="hljs-comment">//写在接口方法上，该接口的所有实现类的该方法都会有事务</span><br><span class="hljs-comment">//写在实现类上，该类中的所有方法都会有事务</span><br><span class="hljs-comment">//写在实现类方法上，该方法上有事务</span><br><span class="hljs-comment">//建议写在实现类或实现类的方法上</span><br></code></pre></td></tr></table></figure><p>2.在JdbcConfig类中配置事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(driver);<br>        ds.setUrl(url);<br>        ds.setUsername(userName);<br>        ds.setPassword(password);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br><br>    <span class="hljs-comment">//配置事务管理器，mybatis使用的是jdbc事务</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">transactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>();<br>        transactionManager.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> transactionManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.开启事务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class</span><br><span class="hljs-meta">//开启注解式事务驱动</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">public class SpringConfig &#123;</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p>4.:运行测试类</p><p><strong>知识点1：@EnableTransactionManagement</strong></p><table><thead><tr><th>名称</th><th>@EnableTransactionManagement</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>设置当前Spring环境中开启注解式事务支持</td></tr></tbody></table><p><strong>知识点2：@Transactional</strong>   </p><table><thead><tr><th>名称</th><th>@Transactional</th></tr></thead><tbody><tr><td>类型</td><td>接口注解  类注解  方法注解</td></tr><tr><td>位置</td><td>业务层接口上方  业务层实现类上方  业务方法上方</td></tr><tr><td>作用</td><td>为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）</td></tr></tbody></table><h3 id="3-3-Spring事务角色"><a href="#3-3-Spring事务角色" class="headerlink" title="3.3 Spring事务角色"></a>3.3 Spring事务角色</h3><p><strong>1.未开启Spring事务之前</strong></p><p><img src="/Spring3/image-20231026102556363.png" alt="image-20231026102556363"></p><ul><li>AccountDao的outMoney因为是修改操作，会开启一个事务T1</li><li>AccountDao的inMoney因为是修改操作，会开启一个事务T2</li><li>AccountService的transfer没有事务，<ul><li>运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确</li><li>如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行</li><li>就会导致数据出现错误</li></ul></li></ul><p><strong>2.开启Spring的事务管理后</strong></p><p><img src="/Spring3/image-20231026102702499.png" alt="image-20231026102702499"></p><ul><li>transfer上添加了@Transactional注解，在该方法上就会有一个事务T</li><li>AccountDao的outMoney方法的事务T1加入到transfer的事务T中</li><li>AccountDao的inMoney方法的事务T2加入到transfer的事务T中</li><li>这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</li></ul><p><strong>事务管理员：</strong>发起事务方，在Spring中通常指代业务层开启事务的方法 </p><p><strong>事务协调员：</strong>加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</p><h3 id="3-4-Spring事务属性"><a href="#3-4-Spring事务属性" class="headerlink" title="3.4 Spring事务属性"></a>3.4 Spring事务属性</h3><p>并不是所有的异常都会回滚事务，比如下面的代码就不会回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转账操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 传出方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in 转入方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money 金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//配置当前接口方法具有事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br><span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        accountDao.outMoney(out,money);<br>        <span class="hljs-comment">//int i = 1/0; //这个异常事务会回滚</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(); <span class="hljs-comment">//这个异常事务就不会回滚</span><br>        &#125;<br>        accountDao.inMoney(in,money);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//出现这个问题的原因是，Spring的事务只会对Error异常和RuntimeException异常及其子类进行事务回顾，其他的异常类型是不会回滚的，对应IOException不符合上述条件所以不回滚</span><br></code></pre></td></tr></table></figure><p>此时就可以使用rollbackFor属性来设置出现IOException异常不回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br> <span class="hljs-meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        accountDao.outMoney(out,money);<br>        <span class="hljs-comment">//int i = 1/0; //这个异常事务会回滚</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(); <span class="hljs-comment">//这个异常事务就不会回滚</span><br>        &#125;<br>        accountDao.inMoney(in,money);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-转账业务追加日志案例"><a href="#3-5-转账业务追加日志案例" class="headerlink" title="3.5 转账业务追加日志案例"></a>3.5 转账业务追加日志案例</h3><p>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 </p><p>需求微缩：A账户减钱，B账户加钱，数据库记录日志</p><p>基于上述的业务需求，我们来分析下该如何实现: </p><p>①：基于转账操作案例添加日志模块，实现数据库中记录日志 </p><p>②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 </p><p>需要注意一点就是，我们这个案例的预期效果为: <strong>无论转账操作是否成功</strong>，<strong>均进行转账操作的日志留痕</strong></p><p>1.创建日志表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tbl_log(<br>   id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>   info <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>   createDate datetime<br>)<br></code></pre></td></tr></table></figure><p>2.添加LogDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LogDao</span> &#123;<br>    <span class="hljs-meta">@Insert(&quot;insert into tbl_log (info,createDate) values(#&#123;info&#125;,now())&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String info)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.添加LogService接口与实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LogService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String out, String in, Double money)</span>;<br>&#125;<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LogService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LogDao logDao;<br><span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String out,String in,Double money )</span> &#123;<br>        logDao.log(<span class="hljs-string">&quot;转账操作由&quot;</span>+out+<span class="hljs-string">&quot;到&quot;</span>+in+<span class="hljs-string">&quot;,金额：&quot;</span>+money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.在转账的业务中添加记录日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转账操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 传出方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in 转入方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money 金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//配置当前接口方法具有事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span><span class="hljs-keyword">throws</span> IOException ;<br>&#125;<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LogService logService;<br><span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String out,String in ,Double money)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            accountDao.outMoney(out,money);<br>            accountDao.inMoney(in,money);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            logService.log(out,in,money);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>5.运行程序</p><ul><li>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功</li><li>当转账业务之间出现异常(int i &#x3D;1&#x2F;0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据</li><li>这个结果和我们想要的不一样，什么原因?该如何解决?</li><li><strong>失败原因:日志的记录与转账操作隶属同一个事务，同成功同失败</strong></li><li>最终效果:无论转账操作是否成功，日志必须保留</li></ul><h3 id="3-6-事务传播行为"><a href="#3-6-事务传播行为" class="headerlink" title="3.6 事务传播行为"></a>3.6 事务传播行为</h3><p><img src="/Spring3/image-20231026111648657.png" alt="image-20231026111648657"></p><ul><li>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3</li><li>transfer因为加了@Transactional注解，也开启了事务T</li><li>前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中</li><li>所以当转账失败后，所有的事务都回滚，导致日志没有记录下来</li><li>这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?</li></ul><p><strong>事务传播行为：</strong>事务协调员对事务管理员所携带事务的处理态度</p><p>1.修改logService改变事务的传播行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LogService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LogDao logDao;<br><span class="hljs-comment">//propagation设置事务属性：传播行为设置为当前操作需要新事务</span><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String out,String in,Double money )</span> &#123;<br>        logDao.log(<span class="hljs-string">&quot;转账操作由&quot;</span>+out+<span class="hljs-string">&quot;到&quot;</span>+in+<span class="hljs-string">&quot;,金额：&quot;</span>+money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-第三方bean、注解开发</title>
    <link href="/2023/10/24/Spring-%E7%AC%AC%E4%B8%89%E6%96%B9bean%E3%80%81%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    <url>/2023/10/24/Spring-%E7%AC%AC%E4%B8%89%E6%96%B9bean%E3%80%81%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-IOC-DI配置第三方bean"><a href="#1-IOC-DI配置第三方bean" class="headerlink" title="1.IOC&#x2F;DI配置第三方bean"></a>1.IOC&#x2F;DI配置第三方bean</h2><h3 id="1-1-案例"><a href="#1-1-案例" class="headerlink" title="1.1 案例"></a>1.1 案例</h3><p><strong>目的：</strong>使用Spring的IOC容器来管理Druid连接池对象</p><p>1.使用第三方的技术，需要在pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.在配置文件applicationContext.xml中将【第三方的类】制作成一个bean，让IOC容器进行管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3..从IOC容器中获取对应的bean对象，将其打印到控制台查看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-第三方bean属性优化"><a href="#1-2-第三方bean属性优化" class="headerlink" title="1.2 第三方bean属性优化"></a>1.2 第三方bean属性优化</h3><p><strong>目的：</strong>将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入</p><p>1.在resources下创建一个jdbc.properties(文件的名称可以任意)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring_db</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>2.开启context命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.在Spring的配置文件中加载properties文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>4.使用加载到的值实现属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-读取单个属性"><a href="#1-3-读取单个属性" class="headerlink" title="1.3 读取单个属性"></a>1.3 读取单个属性</h3><p><strong>目的：</strong>从properties配置文件中读取key为name的值，并将其注入到BookDao中并在save方法中进行打印</p><p>1.在项目中添对应的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.完成配置文件的读取与注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;</span><br><span class="hljs-string">            http://www.springframework.org/schema/beans</span><br><span class="hljs-string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="hljs-string">            http://www.springframework.org/schema/context</span><br><span class="hljs-string">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;<br>    <br>    &lt;context:property-placeholder location=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;<br>    <br>    &lt;bean id=<span class="hljs-string">&quot;bookDao&quot;</span> class=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;<br>    &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>3.运行程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br>        bookDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-核心容器"><a href="#2-核心容器" class="headerlink" title="2.核心容器"></a>2.核心容器</h2><h3 id="2-1-容器创建方式"><a href="#2-1-容器创建方式" class="headerlink" title="2.1 容器创建方式"></a>2.1 容器创建方式</h3><p>类路径下的XML配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<span class="hljs-comment">//常用</span><br></code></pre></td></tr></table></figure><p>文件系统下的XML配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-2-bean的三种获取方式"><a href="#2-2-bean的三种获取方式" class="headerlink" title="2.2 bean的三种获取方式"></a>2.2 bean的三种获取方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>，BookDao.class);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> ctx.getBean(BookDao.class);<br></code></pre></td></tr></table></figure><h3 id="2-3-容器类层次结构"><a href="#2-3-容器类层次结构" class="headerlink" title="2.3 容器类层次结构"></a>2.3 容器类层次结构</h3><p><img src="/Spring2/image-20231024204137991.png" alt="image-20231024204137991"></p><h3 id="2-4-BeanFactory"><a href="#2-4-BeanFactory" class="headerlink" title="2.4 BeanFactory"></a>2.4 BeanFactory</h3><p>使用BeanFactory创建的容器是延迟加载 </p><p>使用ApplicationContext创建的容器是立即加载 </p><h2 id="3-注解开发"><a href="#3-注解开发" class="headerlink" title="3.注解开发"></a>3.注解开发</h2><h3 id="3-1-注解开发定义bean"><a href="#3-1-注解开发定义bean" class="headerlink" title="3.1 注解开发定义bean"></a>3.1 注解开发定义bean</h3><p>1.删除原XML配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2.Dao上添加注解,在BookDaoImpl类上添加@Component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;bookDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span> );<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的</span><br></code></pre></td></tr></table></figure><p><img src="/Spring2/image-20231024204701500.png" alt="image-20231024204701500"></p><p>3.配置Spring的注解包扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.运行程序</p><p>5.Service上添加注解</p><p>6.运行程序</p><p><strong>知识点1@Component</strong></p><table><thead><tr><th>名称</th><th>@Component&#x2F;@Controller&#x2F;@Service&#x2F;@Repository</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类为spring管理的bean</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h3 id="3-2-纯注解开发模式"><a href="#3-2-纯注解开发模式" class="headerlink" title="3.2 纯注解开发模式"></a>3.2 纯注解开发模式</h3><p><strong>目的：</strong>将配置文件applicationContext.xml删除掉，使用类来替换。</p><p>1.创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.标识该类为配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.用注解替换包扫描配置</p><p>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.创建运行类并执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppForAnnotation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br>        System.out.println(bookDao);<br>        <span class="hljs-type">BookService</span> <span class="hljs-variable">bookService</span> <span class="hljs-operator">=</span> ctx.getBean(BookService.class);<br>        System.out.println(bookService);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>主要内容</strong></p><p>1.Java类替换Spring核心配置文件</p><p><img src="/Spring2/image-20231024210457125.png" alt="image-20231024210457125"></p><p>2.@Configuration注解用于设定当前类为配置类</p><p>3.@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&#123;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span><br></code></pre></td></tr></table></figure><p>4.读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载配置文件初始化容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">//加载配置类初始化容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br></code></pre></td></tr></table></figure><p><strong>知识点1：@Configuration</strong></p><table><thead><tr><th>名称</th><th>@Configuration</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类为spring配置类</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><p><strong>知识点2：@ComponentScan</strong></p><table><thead><tr><th>名称</th><th>@ComponentScan</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td>属性</td><td>value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><h3 id="3-3-bean的作用范围"><a href="#3-3-bean的作用范围" class="headerlink" title="3.3 bean的作用范围"></a>3.3 bean的作用范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-comment">//@Scope设置bean的作用范围</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@Scope</strong></p><table><thead><tr><th>名称</th><th>@Scope</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类创建对象的作用范围<br>可用于设置创建出的bean是否为单例对象</td></tr><tr><td>属性</td><td>value（默认）：定义bean作用范围，<br>&#x3D;&#x3D;默认值singleton（单例），可选值prototype（非单例）&#x3D;&#x3D;</td></tr></tbody></table><h3 id="3-4-Bean的生命周期"><a href="#3-4-Bean的生命周期" class="headerlink" title="3.4 Bean的生命周期"></a>3.4 Bean的生命周期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">//在构造方法之后执行，替换 init-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;init ...&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@PreDestroy</span> <span class="hljs-comment">//在销毁方法之前执行,替换 destroy-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;destroy ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>知识点1：@PostConstruct</strong></p><table><thead><tr><th>名称</th><th>@PostConstruct</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法上</td></tr><tr><td>作用</td><td>设置该方法为初始化方法</td></tr><tr><td>属性</td><td>无</td></tr></tbody></table><p><strong>知识点2：@PreDestroy</strong></p><table><thead><tr><th>名称</th><th>@PreDestroy</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法上</td></tr><tr><td>作用</td><td>设置该方法为销毁方法</td></tr><tr><td>属性</td><td>无</td></tr></tbody></table><p><img src="/Spring2/image-20231024211253128.png" alt="image-20231024211253128"></p><h3 id="3-5-注解开发依赖注入"><a href="#3-5-注解开发依赖注入" class="headerlink" title="3.5 注解开发依赖注入"></a>3.5 注解开发依赖注入</h3><h4 id="3-5-1-注解实现按照类型注入"><a href="#3-5-1-注解实现按照类型注入" class="headerlink" title="3.5.1.注解实现按照类型注入"></a>3.5.1.注解实现按照类型注入</h4><p>在BookServiceImpl类的bookDao属性上添加@Autowired注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br>    <br><span class="hljs-comment">//  public void setBookDao(BookDao bookDao) &#123;</span><br><span class="hljs-comment">//        this.bookDao = bookDao;</span><br><span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book service save ...&quot;</span>);<br>        bookDao.save();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是写在属性上并将</span><br><span class="hljs-comment">//setter方法删除掉</span><br><span class="hljs-comment">//为什么setter方法可以删除呢?</span><br><span class="hljs-comment">//自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</span><br><span class="hljs-comment">//普通反射只能获取public修饰的内容</span><br><span class="hljs-comment">//暴力反射除了获取public修饰的内容还可以获取private修改的内容</span><br><span class="hljs-comment">//所以此处无需提供setter方法</span><br></code></pre></td></tr></table></figure><p>@Autowired是按照类型注入,一个接口多个实现类会报错</p><h4 id="3-5-2-注解实现按名称注入"><a href="#3-5-2-注解实现按名称注入" class="headerlink" title="3.5.2 注解实现按名称注入"></a>3.5.2 注解实现按名称注入</h4><p>先给两个Dao类分别起个名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository(&quot;bookDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span> );<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Repository(&quot;bookDao2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...2&quot;</span> );<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，</span><br><span class="hljs-comment">//为什么不报错?</span><br><span class="hljs-comment">//@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和</span><br><span class="hljs-comment">//Bean的名称匹配。因为变量名叫bookDao而容器中也有一个booDao，所以可以成功注入。</span><br></code></pre></td></tr></table></figure><p><img src="/Spring2/image-20231024211949077.png" alt="image-20231024211949077"></p><p>这种情况下不能装配成功，因为因为按照类型会找到多个bean对象，此时会按照bookDao名称去找，因为IOC容器只有 名称叫bookDao1和bookDao2 ,所以找不到，会报NoUniqueBeanDefinitionException</p><p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如 何解决，就需要使用到@Qualifier来指定注入哪个名称的bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;bookDao1&quot;)</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book service save ...&quot;</span>);<br>        bookDao.save();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//@Qualifier注解后的值就是需要注入的bean的名称。</span><br><span class="hljs-comment">//注意:@Qualifier不能独立使用，必须和@Autowired一起使用</span><br></code></pre></td></tr></table></figure><h4 id="3-5-3-简单数据类型注入"><a href="#3-5-3-简单数据类型注入" class="headerlink" title="3.5.3  简单数据类型注入"></a>3.5.3  简单数据类型注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository(&quot;bookDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;itheima&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-4-注解读取properites配置文件"><a href="#3-5-4-注解读取properites配置文件" class="headerlink" title="3.5.4 注解读取properites配置文件"></a>3.5.4 注解读取properites配置文件</h4><p>@Value一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><p>步骤1：resource下准备properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">itheima888</span><br></code></pre></td></tr></table></figure><p>步骤2： 使用注解加载properties配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤3：使用@Value读取配置文件中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository(&quot;bookDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤4:运行程序</p><p><strong>注意：</strong></p><ul><li><p>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span><br></code></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>,运行会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span><br></code></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>知识点1：@Autowired</strong></p><table><thead><tr><th>名称</th><th>@Autowired</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）  或  方法形参注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方  或  方法形参前面</td></tr><tr><td>作用</td><td>为引用类型属性设置值</td></tr><tr><td>属性</td><td>required：true&#x2F;false，定义该属性是否允许为null</td></tr></tbody></table><p><strong>知识点2：@Qualifier</strong></p><table><thead><tr><th>名称</th><th>@Qualifier</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方</td></tr><tr><td>作用</td><td>为引用类型属性指定注入的beanId</td></tr><tr><td>属性</td><td>value（默认）：设置注入的beanId</td></tr></tbody></table><p><strong>知识点3：@Value</strong></p><table><thead><tr><th>名称</th><th>@Value</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方</td></tr><tr><td>作用</td><td>为  基本数据类型  或  字符串类型  属性设置值</td></tr><tr><td>属性</td><td>value（默认）：要注入的属性值</td></tr></tbody></table><p><strong>知识点4：@PropertySource</strong></p><table><thead><tr><th>名称</th><th>@PropertySource</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>加载properties文件中的属性值</td></tr><tr><td>属性</td><td>value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td></tr></tbody></table><h3 id="4-IOC-DI注解开发管理第三方"><a href="#4-IOC-DI注解开发管理第三方" class="headerlink" title="4.IOC&#x2F;DI注解开发管理第三方"></a>4.IOC&#x2F;DI注解开发管理第三方</h3><h4 id="4-1-注解开发管理第三方bean"><a href="#4-1-注解开发管理第三方bean" class="headerlink" title="4.1 注解开发管理第三方bean"></a>4.1 注解开发管理第三方bean</h4><p>1.导入对应的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.在配置类中添加一个方法,注意该方法的返回值就是要创建的Bean对象类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        ds.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);<br>        ds.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        ds.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.在方法上添加@Bean注解,@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        ds.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);<br>        ds.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        ds.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意:不能使用DataSource ds = new DruidDataSource()</span><br><span class="hljs-comment">//因为DataSource接口中没有对应的setter方法来设置属性。</span><br></code></pre></td></tr></table></figure><p>4.从IOC容器中获取对象并打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> ctx.getBean(DataSource.class);<br>        System.out.println(dataSource);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-引入外部配置类"><a href="#4-2-引入外部配置类" class="headerlink" title="4.2 引入外部配置类"></a>4.2 引入外部配置类</h4><p>数据源的bean,我们新建一个JdbcConfig配置类，并把数据源配置到该类下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        ds.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);<br>        ds.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        ds.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中?</p><h5 id="4-2-1-使用包扫描引入"><a href="#4-2-1-使用包扫描引入" class="headerlink" title="4.2.1 使用包扫描引入"></a>4.2.1 使用包扫描引入</h5><p>1.在Spring的配置类上添加包扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima.config&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2.在JdbcConfig上添加配置注解,JdbcConfig类要放入到com.itheima.config包下，需要被Spring的配置类扫描到即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        ds.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);<br>        ds.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        ds.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.运行程序</p><h5 id="4-2-2-使用-Import引入"><a href="#4-2-2-使用-Import引入" class="headerlink" title="4.2.2 使用@Import引入"></a>4.2.2 使用@Import引入</h5><p>1.去除JdbcConfig类上的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        ds.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);<br>        ds.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        ds.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在Spring配置类中引入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span><br><span class="hljs-meta">@Import(&#123;JdbcConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//扫描注解可以移除</span><br><span class="hljs-comment">//@Import参数需要的是一个数组，可以引入多个配置类。</span><br><span class="hljs-comment">//@Import注解在配置类中只能写一次，下面的方式是不允许的</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span><br><span class="hljs-meta">@Import(JdbcConfig.class)</span><br><span class="hljs-meta">@Import(Xxx.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>3.运行程序</p><p><strong>知识点1：@Bean</strong></p><table><thead><tr><th>名称</th><th>@Bean</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法定义上方</td></tr><tr><td>作用</td><td>设置该方法的返回值作为spring管理的bean</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><p><strong>知识点2：@Import</strong></p><table><thead><tr><th>名称</th><th>@Import</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>导入配置类</td></tr><tr><td>属性</td><td>value（默认）：定义导入的配置类类名，<br>当配置类有多个时使用数组格式一次性导入多个配置类</td></tr></tbody></table><h4 id="4-3-注解开发实现为第三方bean注入资源"><a href="#4-3-注解开发实现为第三方bean注入资源" class="headerlink" title="4.3 注解开发实现为第三方bean注入资源"></a>4.3 注解开发实现为第三方bean注入资源</h4><p>在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办? </p><p>这些资源会有两大类，分别是简单数据类型和引用数据类型。</p><h5 id="4-3-1-简单数据类型"><a href="#4-3-1-简单数据类型" class="headerlink" title="4.3.1 简单数据类型"></a>4.3.1 简单数据类型</h5><p>1.类中提供四个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String password;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        ds.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);<br>        ds.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        ds.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.使用<code>@Value</code>注解引入值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;jdbc:mysql://localhost:3306/spring_db&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;root&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;password&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(driver);<br>        ds.setUrl(url);<br>        ds.setUsername(userName);<br>        ds.setPassword(password);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提 取到jdbc.properties配置文件</p><p>1.resources目录下添加jdbc.properties</p><p>2.配置文件中提供四个键值对分别是数据库的四要素</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/spring_db</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">password</span><br></code></pre></td></tr></table></figure><p>3.使用@PropertySource加载jdbc.properties配置文件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;jdbc.properties&quot;)</span><br>publi <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.修改@Value注解属性的值，将其修改为${key}，key就是键值对中的键的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        ds.setDriverClassName(driver);<br>        ds.setUrl(url);<br>        ds.setUsername(userName);<br>        ds.setPassword(password);<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-2-引用数据类型"><a href="#4-3-2-引用数据类型" class="headerlink" title="4.3.2 引用数据类型"></a>4.3.2 引用数据类型</h5><p>1.在SpringConfig中扫描BookDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.itheima.dao&quot;)</span><br><span class="hljs-meta">@Import(&#123;JdbcConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在jdbcConfig类的方法上添加参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(BookDao bookDao)</span>&#123;<br>    System.out.println(bookDao);<br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    ds.setDriverClassName(driver);<br>    ds.setUrl(url);<br>    ds.setUsername(userName);<br>    ds.setPassword(password);<br>    <span class="hljs-keyword">return</span> ds;<br>&#125;<br><span class="hljs-comment">//引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。</span><br></code></pre></td></tr></table></figure><h3 id="5-注解总结"><a href="#5-注解总结" class="headerlink" title="5.注解总结"></a>5.注解总结</h3><p><img src="/Spring2/image-20231025103317782.png" alt="image-20231025103317782"></p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-IOC/DI</title>
    <link href="/2023/10/24/Spring-IOC%E3%80%81DI/"/>
    <url>/2023/10/24/Spring-IOC%E3%80%81DI/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-Spring-IoC-DI"><a href="#1-Spring-IoC-DI" class="headerlink" title="1.Spring-IoC&#x2F;DI"></a>1.Spring-IoC&#x2F;DI</h2><h3 id="1-1-Spring之前遇到问题"><a href="#1-1-Spring之前遇到问题" class="headerlink" title="1.1 Spring之前遇到问题"></a>1.1 Spring之前遇到问题</h3><p>业务层需要调用数据层的方法，就需要在业务层new数据层的对象，如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译 打包和重部署，<strong>耦合度偏高</strong></p><p><img src="/Spring1/image-20231024153648095.png" alt="image-20231024153648095"></p><p>能不能把这个new去掉，所以引入<strong>IOC控制反转</strong></p><h3 id="1-2-IOC（控制反转）"><a href="#1-2-IOC（控制反转）" class="headerlink" title="1.2 IOC（控制反转）"></a>1.2 IOC（控制反转）</h3><p>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为<strong>控制反转</strong></p><p>Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的”外部”</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">1.IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象<br>2.被创建或被管理的对象在IOC容器中统称为Bean<br>3.IOC容器中放的就是一个个的Bean对象<br></code></pre></td></tr></table></figure><p>当IOC容器中创建好service和dao对象后，程序还不能正确执行，还需要将容器中建立对象与对象之间的绑定关系，这时候就引入了<strong>DI（依赖注入）</strong></p><h3 id="1-3-DI-依赖注入"><a href="#1-3-DI-依赖注入" class="headerlink" title="1.3 DI(依赖注入)"></a>1.3 DI(依赖注入)</h3><p><strong>依赖注入：</strong>在容器中建立bean与bean之间的依赖关系的整个过程</p><p><img src="/Spring1/image-20231024154113738.png" alt="image-20231024154113738"></p><p><strong>总结：</strong></p><p>1.使用IOC容器管理bean</p><p>2.在IOC容器内将有依赖关系的bean进行关系绑定（DI）</p><p>3.最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</p><h3 id="1-4-IOC案例"><a href="#1-4-IOC案例" class="headerlink" title="1.4 IOC案例"></a>1.4 IOC案例</h3><p><strong>目的：</strong>将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean 对象进行方法调用</p><ol><li><p>创建Maven的java项目</p></li><li><p>pom.xml添加Spring的依赖jar包</p></li><li><p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p></li><li><p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--bean标签标示配置bean</span><br><span class="hljs-comment">id属性标示给bean起名字</span><br><span class="hljs-comment">class属性表示给bean定义类型</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用Spring提供的接口完成IOC容器的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取IOC容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>从容器中获取对象进行方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取IOC容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>); <br><span class="hljs-comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br><span class="hljs-comment">//        bookDao.save();</span><br>        <span class="hljs-type">BookService</span> <span class="hljs-variable">bookService</span> <span class="hljs-operator">=</span> (BookService) ctx.getBean(<span class="hljs-string">&quot;bookService&quot;</span>);<br>        bookService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-DI案例"><a href="#1-5-DI案例" class="headerlink" title="1.5 DI案例"></a>1.5 DI案例</h3><p><strong>目的：</strong>基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成 Dao层的注入</p><p>1.删除业务层中使用new的方式创建的dao对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-comment">//删除业务层中使用new的方式创建的dao对象</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book service save ...&quot;</span>);<br>        bookDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在业务层提供BookDao的setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-comment">//删除业务层中使用new的方式创建的dao对象</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book service save ...&quot;</span>);<br>        bookDao.save();<br>    &#125;<br>    <span class="hljs-comment">//提供对应的set方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookDao</span><span class="hljs-params">(BookDao bookDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookDao = bookDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.在配置文件中添加依赖注入的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br>    &lt;!--bean标签标示配置bean<br>    id属性标示给bean起名字<br>    class属性表示给bean定义类型<br>--&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;bookDao&quot;</span> class=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;bookService&quot;</span> class=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;<br>        &lt;!--配置server与dao的关系--&gt;<br>        &lt;!--property标签表示配置当前bean的属性<br>        name属性表示配置哪一个具体的属性<br>        ref属性表示参照哪一个bean<br>--&gt;<br>        &lt;property name=<span class="hljs-string">&quot;bookDao&quot;</span> ref=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;<br>    &lt;/bean&gt;<br><br>&lt;/beans&gt;<br> <br><span class="hljs-comment">//注意:配置中的两个bookDao的含义是不一样的</span><br><span class="hljs-comment">// name=&quot;bookDao&quot;中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</span><br><span class="hljs-comment">// ref=&quot;bookDao&quot;中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</span><br></code></pre></td></tr></table></figure><p><img src="/Spring1/image-20231024160025036.png" alt="image-20231024160025036"></p><p>4.运行程序调用方法</p><h3 id="1-6-bean基础配置"><a href="#1-6-bean基础配置" class="headerlink" title="1.6 bean基础配置"></a>1.6 bean基础配置</h3><p><img src="/Spring1/image-20231024160405389.png" alt="image-20231024160405389"></p><h3 id="1-7-bean实例化"><a href="#1-7-bean实例化" class="headerlink" title="1.7 bean实例化"></a>1.7 bean实例化</h3><p>bean的构造是通过构造方法来构造的，Spring的IOC实例化对象的三种方式分别为：构造方法(常用) 、静态工厂(了解)、 实例工厂(了解)（FactoryBean（实用））</p><h3 id="1-8-bean生命周期"><a href="#1-8-bean生命周期" class="headerlink" title="1.8 bean生命周期"></a>1.8 bean生命周期</h3><p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式了解下即可。</li></ul><p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p><ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)</li><li>&#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D;</li></ul></li><li>使用bean<ul><li>1.执行业务操作</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>&#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D;</li></ul></li></ul><p>(3)关闭容器的两种方式:</p><ul><li>ConfigurableApplicationContext是ApplicationContext的子类<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul><h3 id="1-9-DI中的setter注入"><a href="#1-9-DI中的setter注入" class="headerlink" title="1.9 DI中的setter注入"></a>1.9 DI中的setter注入</h3><p>注入的类型有两种：<strong>简单类型</strong>和<strong>引用类型</strong></p><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-0-DI中的构造器注入"><a href="#2-0-DI中的构造器注入" class="headerlink" title="2.0 DI中的构造器注入"></a>2.0 DI中的构造器注入</h3><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-1-DI中的自动配置注入"><a href="#2-1-DI中的自动配置注入" class="headerlink" title="2.1 DI中的自动配置注入"></a>2.1 DI中的自动配置注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>/&gt;</span><br>    or<br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-DI中的集合注入"><a href="#2-2-DI中的集合注入" class="headerlink" title="2.2 DI中的集合注入"></a>2.2 DI中的集合注入</h3><p>注入数组类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;array&quot;</span>&gt;<br>    &lt;array&gt;<br>        &lt;value&gt;<span class="hljs-number">100</span>&lt;/value&gt;<br>        &lt;value&gt;<span class="hljs-number">200</span>&lt;/value&gt;<br>        &lt;value&gt;<span class="hljs-number">300</span>&lt;/value&gt;<br>    &lt;/array&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><p> 注入List类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;list&quot;</span>&gt;<br>    &lt;list&gt;<br>        &lt;value&gt;itcast&lt;/value&gt;<br>        &lt;value&gt;itheima&lt;/value&gt;<br>        &lt;value&gt;boxuegu&lt;/value&gt;<br>        &lt;value&gt;chuanzhihui&lt;/value&gt;<br>    &lt;/list&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><p>注入Set类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;set&quot;</span>&gt;<br>    &lt;set&gt;<br>        &lt;value&gt;itcast&lt;/value&gt;<br>        &lt;value&gt;itheima&lt;/value&gt;<br>        &lt;value&gt;boxuegu&lt;/value&gt;<br>        &lt;value&gt;boxuegu&lt;/value&gt;<br>    &lt;/set&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><p>注入Map类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;map&quot;</span>&gt;<br>    &lt;map&gt;<br>        &lt;entry key=<span class="hljs-string">&quot;country&quot;</span> value=<span class="hljs-string">&quot;china&quot;</span>/&gt;<br>        &lt;entry key=<span class="hljs-string">&quot;province&quot;</span> value=<span class="hljs-string">&quot;henan&quot;</span>/&gt;<br>        &lt;entry key=<span class="hljs-string">&quot;city&quot;</span> value=<span class="hljs-string">&quot;kaifeng&quot;</span>/&gt;<br>    &lt;/map&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><p>注入Properties类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;properties&quot;</span>&gt;<br>    &lt;props&gt;<br>        &lt;prop key=<span class="hljs-string">&quot;country&quot;</span>&gt;china&lt;/prop&gt;<br>        &lt;prop key=<span class="hljs-string">&quot;province&quot;</span>&gt;henan&lt;/prop&gt;<br>        &lt;prop key=<span class="hljs-string">&quot;city&quot;</span>&gt;kaifeng&lt;/prop&gt;<br>    &lt;/props&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库-锁、死锁、排查</title>
    <link href="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%94%81%E3%80%81%E6%AD%BB%E9%94%81%E3%80%81%E6%8E%92%E6%9F%A5/"/>
    <url>/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%94%81%E3%80%81%E6%AD%BB%E9%94%81%E3%80%81%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库3"><a href="#数据库3" class="headerlink" title="数据库3"></a>数据库3</h1><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><h3 id="1-1-为什么要加锁"><a href="#1-1-为什么要加锁" class="headerlink" title="1.1 为什么要加锁"></a>1.1 为什么要加锁</h3><p>当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><h3 id="1-2-锁的分类"><a href="#1-2-锁的分类" class="headerlink" title="1.2 锁的分类"></a>1.2 锁的分类</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022213448654.png" alt="image-20231022213448654"></p><h4 id="1-2-1-乐观锁"><a href="#1-2-1-乐观锁" class="headerlink" title="1.2.1 乐观锁"></a>1.2.1 乐观锁</h4><p>乐观锁并不是一个真的锁，而是一种思想，CAS（compare and swap）技术，CAS流程如下</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022211807774.png" alt="image-20231022211807774"></p><p>乐观锁不需要加锁就可以实现锁的功能，但是乐观锁有一个很严重的问题就是ABA问题</p><p><strong>本质：</strong>在于CAS在修改变量的时候，无法记录变量的状态，比如修改的次数，是否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成CAS多次执行的问题</p><p><strong>解决方案：</strong>添加版本号，这时不仅要比较数值还需要比较版本号，除此之外，我们也可以用时间戳来进行比较，看看数据是否是新数据</p><p><strong>CAS优点：</strong>并发情况好，不用上锁</p><p><strong>CAS缺点：</strong>循环时间长开销大、只能保证一个共享变量的原子操作</p><h4 id="1-2-2-悲观锁"><a href="#1-2-2-悲观锁" class="headerlink" title="1.2.2 悲观锁"></a>1.2.2 悲观锁</h4><p><strong>1.全局锁：</strong>对整个数据库实例加锁，用于全库逻辑备份</p><p><strong>2.表级锁：</strong>当前操作的整张表加锁，最常使用的 MyISAM 与 InnoDB 都支持表级锁定</p><p><strong>3.页级锁：</strong>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 引擎支持页级锁。</p><p><strong>4.行级锁：</strong>行级锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。MySQL中只有InnoDB支持行级锁，行级锁分为共享锁和排他锁。</p><h4 id="1-2-3-共享锁与排他锁"><a href="#1-2-3-共享锁与排他锁" class="headerlink" title="1.2.3 共享锁与排他锁"></a>1.2.3 共享锁与排他锁</h4><p><strong>共享锁：</strong>又称之为读锁，简称S锁，当事务A对数据加上读锁后，其他事务只能对该数据加读锁，不能做任何修改操作，也就是不能添加写锁。只有当事务A上的读锁被释放后，其他事务才能对其添加写锁。</p><p><strong>排他锁：</strong>排它锁，又称之为写锁，简称X锁，当事务对数据加上写锁后，其他事务既不能对该数据添加读写，也不能对该数据添加写锁，写锁与其他锁都是互斥的。只有当前数据写锁被释放后，其他事务才能对其添加写锁或者是读锁。</p><p>MySQL InnoDB引擎默认update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p><h4 id="1-2-4-意向共享锁与意向排他锁"><a href="#1-2-4-意向共享锁与意向排他锁" class="headerlink" title="1.2.4 意向共享锁与意向排他锁"></a>1.2.4 意向共享锁与意向排他锁</h4><p>意向锁是表锁，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><p><strong>作用：</strong>当有事务A有行锁时，MySQL会自动为该表添加意向锁，事务B如果想申请整个表的写锁，那么不需要遍历每一行判断是否存在行锁，而直接判断是否存在意向锁，增强性能。</p><h4 id="1-2-5-间隙锁、临键锁、记录锁"><a href="#1-2-5-间隙锁、临键锁、记录锁" class="headerlink" title="1.2.5 间隙锁、临键锁、记录锁"></a>1.2.5 间隙锁、临键锁、记录锁</h4><p><strong>记录锁：</strong>记录锁是封锁记录，记录锁也叫行锁</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select from goods where id=1 for update;<br></code></pre></td></tr></table></figure><p>它会在 id&#x3D;1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id&#x3D;1 这一行。</p><p><strong>间隙锁：</strong>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select from goods where id between 1 and 10 for update;<br></code></pre></td></tr></table></figure><p>即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1和 10 两条记录行并不会被锁住</p><p><strong>临键锁：</strong>是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间，是一个左开右闭区间。临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。</p><p>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022214453190.png" alt="image-20231022214453190"></p><p>goods表中隐藏的临键锁有：(-∞, 96],(96, 99],(99, +∞]</p><p>session1 在对 number 为 96 的列进行 update 操作的同时，也获取了(-∞, 96],(96, 99]这两个区间内的临键锁。</p><h2 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h2><h3 id="2-1-死锁原因"><a href="#2-1-死锁原因" class="headerlink" title="2.1 死锁原因"></a>2.1 死锁原因</h3><ol><li><strong>互斥条件</strong>：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。</li><li><strong>请求和保持条件</strong>：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。</li><li><strong>不可剥夺条件</strong>：指运算单元已获得的资源，在未使用完之前，不能被剥夺。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。</li></ol><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022214754272.png" alt="image-20231022214754272"></p><h3 id="2-2-死锁解决方案"><a href="#2-2-死锁解决方案" class="headerlink" title="2.2 死锁解决方案"></a>2.2 死锁解决方案</h3><p>接下来我们来分析一下，产生死锁的 4 个条件，哪些是可以破坏的？哪些是不能被破坏的？</p><ul><li>互斥条件：系统特性，不能被破坏。</li><li><strong>请求和保持条件：可以被破坏。</strong></li><li>不可剥夺条件：系统特性，不能被破坏。</li><li><strong>循环等待条件：可以被破坏。</strong></li></ul><p>通过上述分析，我们可以得出结论，我们只能通过破坏请求和保持条件或者是环路等待条件，从而来解决死锁的问题，那上线，我们就先从破坏“环路等待条件”开始来解决死锁问题。</p><h4 id="2-2-1-解决方案1：顺序锁"><a href="#2-2-1-解决方案1：顺序锁" class="headerlink" title="2.2.1  解决方案1：顺序锁"></a>2.2.1  解决方案1：顺序锁</h4><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022215036126.png" alt="image-20231022215036126"></p><p>之前循环等待，但是我们现在规定资源获取顺序是固定的，也就是先A再B，这时候如果线程2没有获取资源A那么也不会去争夺资源B</p><h4 id="2-2-2-解决方案2：轮询锁"><a href="#2-2-2-解决方案2：轮询锁" class="headerlink" title="2.2.2 解决方案2：轮询锁"></a>2.2.2 解决方案2：轮询锁</h4><p>轮询锁是通过打破“请求和保持条件”来避免造成死锁的，它的实现思路简单来说就是通过轮询来尝试获取锁，如果有一个锁获取失败，则释放当前线程拥有的所有锁，等待下一轮再尝试获取锁。</p><h4 id="2-2-3-避免死锁"><a href="#2-2-3-避免死锁" class="headerlink" title="2.2.3 避免死锁"></a>2.2.3 避免死锁</h4><p><strong>银行家算法：</strong>预先分配看看是否会发送死锁，如果存在发送死锁可能性就不分配</p><h2 id="3-发生死锁如何排查"><a href="#3-发生死锁如何排查" class="headerlink" title="3.发生死锁如何排查"></a>3.发生死锁如何排查</h2><p>1.查看正在进行中的事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.INNODB_TRX<br></code></pre></td></tr></table></figure><p>2.查看正在锁的事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;<br></code></pre></td></tr></table></figure><p>3.查看等待锁的事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;<br></code></pre></td></tr></table></figure><p>4.查询是否锁表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW OPEN TABLES where In_use &gt; 0;<br></code></pre></td></tr></table></figure><p>5.查看最近死锁的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engine innodb status<br></code></pre></td></tr></table></figure><p><strong>关键字：EXPLAIN</strong>可以看表的读取顺序、数据读取操作的类型、哪些索引可以使用、哪些索引实际使用、表之间的引用、每张表有多少行被优化器查询</p><h2 id="4-备注"><a href="#4-备注" class="headerlink" title="4.备注"></a>4.备注</h2><p>部分材料来源于：</p><p><a href="https://juejin.cn/post/6931752749545553933">史上最全MySQL各种锁详解 - 掘金 (juejin.cn)</a></p><p><a href="https://cloud.tencent.com/developer/article/1875648">1.3w字，一文详解死锁！-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库-事务、隔离、日志</title>
    <link href="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E3%80%81%E6%97%A5%E5%BF%97/"/>
    <url>/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E3%80%81%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库2"><a href="#数据库2" class="headerlink" title="数据库2"></a>数据库2</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><h3 id="1-1-事务的状态"><a href="#1-1-事务的状态" class="headerlink" title="1.1 事务的状态"></a>1.1 事务的状态</h3><p>事务的状态有三种：Active、Commited、Failed</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014172910037.png" alt="image-20231014172910037"></p><p>但是其实还有很多中间状态，比如部分提交，事务的状态图也会越来越复杂</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014172950181.png" alt="image-20231014172950181"></p><ul><li>Active：事务的初始状态，表示事务正在执行；</li><li>Partially Commited：在最后一条语句执行之后；</li><li>Failed：发现事务无法正常执行之后；</li><li>Aborted：事务被回滚并且数据库恢复到了事务进行之前的状态之后；</li><li>Commited：成功执行整个事务；</li></ul><h3 id="1-2事务的四大特性（ACID"><a href="#1-2事务的四大特性（ACID" class="headerlink" title="1.2事务的四大特性（ACID)"></a>1.2事务的四大特性（ACID)</h3><h4 id="1-2-1-原子性"><a href="#1-2-1-原子性" class="headerlink" title="1.2.1 原子性"></a>1.2.1 原子性</h4><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。</p><p><strong>原子性实现：</strong>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，而在 MySQL 中，恢复机制是通过<em>回滚日志</em>（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014173352748.png" alt="image-20231014173352748"></p><p>回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志<strong>逻辑地</strong>将数据库中的修改撤销掉看，可以<strong>理解</strong>为，我们在事务中使用的每一条 <code>INSERT</code> 都对应了一条 <code>DELETE</code>，每一条 <code>UPDATE</code> 也都对应一条相反的 <code>UPDATE</code> 语句。</p><p><strong>级联回滚：</strong>在下图所示的一次事件中，Transaction2 依赖于 Transaction1，而 Transaction3 又依赖于 Transaction1，当 Transaction1 由于执行出现问题发生回滚时，为了保证事务的原子性，就会将 Transaction2 和 Transaction3 中的工作全部回滚，这种情况也叫做<em>级联回滚</em>（Cascading Rollback），级联回滚的发生会导致大量的工作需要撤回，是我们难以接受的，不过如果想要达到<strong>绝对的</strong>原子性，这件事情又是不得不去处理的。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014173217570.png" alt="image-20231014173217570"></p><h4 id="1-2-2-持久性"><a href="#1-2-2-持久性" class="headerlink" title="1.2.2 持久性"></a>1.2.2 持久性</h4><p>既然是数据库，那么一定对数据的持久存储有着非常强烈的需求，如果数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上；而事务的持久性就体现在，一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。</p><p><strong>持久性实现：</strong>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014173510293.png" alt="image-20231014173510293"></p><p>当我们在一个事务中尝试对数据进行修改时，它<strong>会先将数据从磁盘读入内存，并更新内存中缓存的数据（数据一致性）</strong>，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将<strong>重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上</strong>，图中的第 4、5 步就是在事务提交时执行的。</p><h4 id="1-2-3-隔离性"><a href="#1-2-3-隔离性" class="headerlink" title="1.2.3 隔离性"></a>1.2.3 隔离性</h4><p><strong>隔离级别：</strong></p><ul><li><code>RAED UNCOMMITED</code>（读未提交）：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read（脏读））；</li><li><code>READ COMMITED</code>（读提交）：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read（不可重复读））；</li><li><code>REPEATABLE READ</code>（可重复读）：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li><li><code>SERIALIZABLE</code>（串行化）：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li></ul><p><strong>隔离级别的实现：</strong>锁（共享锁和互斥锁）、时间戳（乐观锁，先对数据进行修改，写回时再去判断当前值，如果时间戳（或者版本）没有改变就写入，否则，再生成一个新的时间戳再更新数据）、多版本和快照隔离，具体内容后面会详细解释</p><h4 id="1-2-4-一致性"><a href="#1-2-4-一致性" class="headerlink" title="1.2.4 一致性"></a>1.2.4 一致性</h4><p>数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</p><p>我们可以将事务理解成一个函数，它接受一个外界的 SQL 输入和一个一致的数据库，它一定会返回一个一致的数据库。</p><p>而第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</p><p>CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；而 ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的</p><h2 id="2-事务四种隔离详解"><a href="#2-事务四种隔离详解" class="headerlink" title="2.事务四种隔离详解"></a>2.事务四种隔离详解</h2><p>首先，事务四种隔离级别为：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ol><h3 id="2-1-读未提交"><a href="#2-1-读未提交" class="headerlink" title="2.1 读未提交"></a>2.1 读未提交</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014174818199.png" alt="image-20231014174818199"></p><p>读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据。这时候就会出现错误。</p><p><strong>后果：</strong>导致读到其他脏数据</p><p><strong>原因：</strong>因为记录并没有加锁，所有人都可以访问到</p><p><strong>解决方案：</strong>对记录加记录锁，这时隔离级别就变成读提交了</p><h3 id="2-2-读提交"><a href="#2-2-读提交" class="headerlink" title="2.2 读提交"></a>2.2 读提交</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014175222304.png" alt="image-20231014175222304"></p><p><strong>后果：</strong>后面读的数据和之前读的不一样，一般情况下不会出现问题，但是如果在数据库备份时，数据还有可能在不断修改，我们肯定希望备份整个数据库开始时的那个版本，而不希望备份的数据有些是之前那个时刻版本的，有些则是之后那个时间版本的。这样导致新来的数据覆盖掉了旧的数据，那么旧的数据就无法再找到了。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180524398.png" alt="image-20231014180524398"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180620939.png" alt="image-20231014180620939"></p><p><strong>原因：</strong>因为对记录加了锁，所以这时候只能读到新数据</p><p><strong>解决方案：</strong>MVCC（多版本和快照隔离），这时隔离级别变成了可重复读</p><h3 id="2-3-可重复读"><a href="#2-3-可重复读" class="headerlink" title="2.3 可重复读"></a>2.3 可重复读</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180804387.png" alt="image-20231014180804387"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180812441.png" alt="image-20231014180812441"></p><p><strong>后果：</strong>两次查询结果不一样</p><p><strong>原因：</strong>因为MVCC（多版本和快照隔离），其实有两种，第一种select是快照读，会保留之前的数据，但是update会给这个记录加锁，这样锁+select就变成了当前读，导致读出来的数据不一样了，通过next-key锁（间隙锁+记录锁)只锁住一部分区间使得有部分区间不会发送幻读</p><p><strong>解决方案：</strong>加表锁，隔离级别变成串行化</p><h3 id="2-4-串行化"><a href="#2-4-串行化" class="headerlink" title="2.4 串行化"></a>2.4 串行化</h3><p>加表锁，运行效率很低，但是隔离级别最高</p><h3 id="2-5-MVCC机制"><a href="#2-5-MVCC机制" class="headerlink" title="2.5 MVCC机制"></a>2.5 MVCC机制</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014203705388.png" alt="image-20231014203705388"></p><p>MVCC由Undo Log和Read View共同实现，Undo Log形成版本链，通过roll_potinter连接起来，并且记录对应的事务结果。</p><p>Read View是select在查询时做的一个内存视图</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015231621744.png" alt="image-20231015231621744"></p><p>RC不可以解决可重复读，两次ReadView都不同</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015231807060.png" alt="image-20231015231807060"></p><p>RR隔离级别，复用之前ReadView</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015232006679.png" alt="image-20231015232006679"></p><p>因为有临键锁，所有加锁的SELECT会变成当前读，导致出现幻读情况</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015232153209.png" alt="image-20231015232153209"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015232356249.png" alt="image-20231015232356249"></p><p>当SELECT没有被临键锁的范围覆盖时，还是会复用之前的ReadView，这时就没有发送幻读</p><h2 id="3-数据库日志"><a href="#3-数据库日志" class="headerlink" title="3.数据库日志"></a>3.数据库日志</h2><h3 id="3-1-重做日志（redo-log）"><a href="#3-1-重做日志（redo-log）" class="headerlink" title="3.1 重做日志（redo log）"></a>3.1 重做日志（redo log）</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231022220311901.png" alt="image-20231022220311901"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231022220340221.png" alt="image-20231022220340221"></p><p>重做日志（redo log）是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。</p><p>InnoDB引擎对数据的更新，是<strong>先将更新记录写入redo log日志</strong>，然后会在系统<strong>空闲</strong>的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的<strong>预写式技术（Write Ahead logging）</strong>。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233136249.png" alt="image-20231015233136249"></p><p>redo log日志的大小是固定的，为了能够持续不断的对更新记录进行写入，在redo log日志中设置了两个标志位置，checkpoint和write_pos，分别表示记录擦除的位置和记录写入的位置。</p><p>当<code>write_pos</code>追上<code>checkpoint</code>时，表示redo log日志已经写满。这时不能继续执行新的数据库更新语句，需要停下来先删除一些记录，执行<strong>checkpoint规则</strong>腾出可写空间。</p><blockquote><p><strong>checkpoint规则：</strong>checkpoint触发后，将buffer中脏数据页和脏日志页都刷到磁盘。<br><strong>脏数据</strong>：指内存中未刷到磁盘的数据。</p></blockquote><p>redo log中最重要的概念就是缓冲池<code>buffer pool</code>，这是在内存中分配的一个区域，包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。</p><blockquote><p>当请求读取数据时，会先判断是否在缓冲池命中，如果未命中才会在磁盘上进行检索后放入缓冲池；<br>当请求写入数据时，会先写入缓冲池，缓冲池中修改的数据会定期刷新到磁盘中。这一过程也被称之为<strong>刷脏</strong> </p></blockquote><p>当数据修改时，除了修改<code>buffer pool</code>中的数据，还会在redo log中记录这次操作；当事务提交时，会根据redo log的记录对数据进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，从而保证了事务的持久性，使得数据库获得<code>crash-safe</code>能力。</p><h4 id="脏日志刷盘"><a href="#脏日志刷盘" class="headerlink" title="脏日志刷盘"></a>脏日志刷盘</h4><p>除了上面提到的对于脏数据的刷盘，实际上redo log日志在记录时，为了保证日志文件的持久化，也需要经历将日志记录从内存写入到磁盘的过程。redo log日志可分为两个部分，一是存在易失性内存中的缓存日志<code>redo log buff</code>，二是保存在磁盘上的redo log日志文件<code>redo log file</code>。<br>为了确保每次记录都能够写入到磁盘中的日志中，每次将<code>redo log buffer</code>中的日志写入<code>redo log file</code>的过程中都会调用一次操作系统的<code>fsync</code>操作。</p><blockquote><p>fsync函数：包含在UNIX系统头文件#include 中，用于同步内存中所有已修改的文件数据到储存设备。</p></blockquote><p>在写入的过程中，还需要经过操作系统内核空间的<code>os buffer</code>。redo log日志的写入过程可见下图。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233627611.png" alt="image-20231015233627611"></p><h3 id="3-2-回滚日志（undo-log）"><a href="#3-2-回滚日志（undo-log）" class="headerlink" title="3.2 回滚日志（undo log）"></a>3.2 回滚日志（undo log）</h3><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231022220250583.png" alt="image-20231022220250583"></p><p>​当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。<br>​但是undo log不redo log不一样，它属于<strong>逻辑日志</strong>。它对SQL语句执行相关的信息进行记录。当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）；对于每个数据删除操作（delete），回滚时会执行数据插入操作（insert）；对于每个数据更新操作（update），回滚时会执行一个相反的数据更新操作（update），把数据改回去。<strong>undo log由两个作用，一是提供回滚，二是实现MVCC</strong>。</p><h3 id="3-3-二进制日志（bin-log）"><a href="#3-3-二进制日志（bin-log）" class="headerlink" title="3.3 二进制日志（bin log）"></a>3.3 二进制日志（bin log）</h3><p>二进制日志binlog是服务层的日志，还被称为归档日志。binlog主要记录数据库的变化情况，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进二进制日志中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步。<br>这里binlog所存储的内容看起来似乎与redo log很相似，但是其实不然。redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑，比如”给ID&#x3D;2这一行的a字段加1 “。binlog日志中的内容是二进制的，根据日记格式参数的不同，可能基于SQL语句、基于数据本身或者二者的混合。一般常用记录的都是SQL语句。</p><p>同时，redo log是基于<code>crash recovery</code>，保证MySQL宕机后的数据恢复；而binlog是基于<code>point-in-time recovery</code>，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份。<br>事实上最开始MySQL是没有redo log日志的。因为起先MySQL是没有InnoDB引擎的，自带的引擎是MyISAM。binlog是服务层的日志，因此所有引擎都能够使用。但是光靠binlog日志只能提供归档的作用，无法提供<code>crash-safe</code>能力，所以InnoDB引擎就采用了学自于Oracle的技术，也就是redo log，这才拥有了<code>crash-safe</code>能力。这里对redo log日志和binlog日志的特点分别进行了对比：</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233948808.png" alt="image-20231015233948808"></p><p>在MySQL执行更新语句时，都会涉及到redo log日志和binlog日志的读写。一条更新语句的执行过程如下：</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233957539.png" alt="image-20231015233957539"></p><p>从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。<br>不仅如此，在对redo log写入时有两个阶段的提交，<strong>一是binlog写入之前prepare状态的写入</strong>，<strong>二是binlog写入之后commit状态的写入</strong>。<br>之所以要安排这么一个<strong>两阶段提交</strong>，自然是有它的道理的。现在我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入redo log，后写入binlog；要么先写入binlog，后写入redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p><h5 id="先写入redo-log，后写入binlog"><a href="#先写入redo-log，后写入binlog" class="headerlink" title="先写入redo log，后写入binlog"></a>先写入redo log，后写入binlog</h5><p>在写完redo log之后，数据此时具有crash-safe能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在redo log写完时候，binlog写入之前，系统发生了宕机。此时binlog没有对上面的更新语句进行保存，导致当使用binlog进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得<code>id=2</code>这一行的数据没有被更新。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015234018336.png" alt="image-20231015234018336"></p><p>由此可见，两阶段的提交就是为了避免上述的问题，使得binlog和redo log中保存的信息是一致的。</p><h3 id="4-主从复制"><a href="#4-主从复制" class="headerlink" title="4.主从复制"></a>4.主从复制</h3><p>主从复制的概念很简单，就是从原来的数据库复制一个完全一样的数据库，原来的数据库称作主数据库，复制的数据库称为从数据库。从数据库会与主数据库进行数据同步，保持二者的数据一致性。</p><p>主从复制的原理实际上就是通过bin log日志实现的。bin log日志中保存了数据库中所有SQL语句，通过对bin log日志中SQL的复制，然后再进行语句的执行即可实现从数据库与主数据库的同步。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231016230053131.png" alt="image-20231016230053131"></p><p>主从复制的过程主要是靠三个线程进行的，一个运行在主服务器中的发送线程，用于发送binlog日志到从服务器。两外两个运行在从服务器上的I&#x2F;O线程和SQL线程。I&#x2F;O线程用于读取主服务器发送过来的binlog日志内容，并拷贝到本地的中继日志中。SQL线程用于读取中继日志中关于数据更新的SQL语句并执行，从而实现主从库的数据一致。</p><p>主从复制能够带来的好处有：</p><blockquote><ol><li>通过复制实现数据的异地备份，当主数据库故障时，可切换从数据库，避免数据丢失。</li><li>可实现架构的扩展，当业务量越来越大，I&#x2F;O访问频率过高时，采用多库的存储，可以降低磁盘I&#x2F;O访问的频率，提高单个机器的I&#x2F;O性能。</li><li>可实现读写分离，使数据库能支持更大的并发。</li><li>实现服务器的负载均衡，通过在主服务器和从服务器之间切分处理客户查询的负荷。</li></ol></blockquote><h3 id="5-备注"><a href="#5-备注" class="headerlink" title="5.备注"></a>5.备注</h3><p>以上资料来源于<a href="https://developer.aliyun.com/article/764178">为了让你彻底弄懂 MySQL 事务日志，我通宵赶出了这份图解！-阿里云开发者社区 (aliyun.com)</a>和<a href="https://www.bilibili.com/video/BV1wu4y1d734/?spm_id_from=333.880.my_history.page.click&vd_source=0fb3165118535b2ba15fe8d267120151">动画讲解：MySQL的MVCC原理，RR不能完全解决幻读问题的底层原理，Undo版本链_哔哩哔哩_bilibili</a>有兴趣的友友可以去看原文和视频</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库-范式、语言、索引</title>
    <link href="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F%E3%80%81%E8%AF%AD%E8%A8%80%E3%80%81%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F%E3%80%81%E8%AF%AD%E8%A8%80%E3%80%81%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库1"><a href="#数据库1" class="headerlink" title="数据库1"></a>数据库1</h1><h2 id="1-三大范式（设计数据库表会用）"><a href="#1-三大范式（设计数据库表会用）" class="headerlink" title="1.三大范式（设计数据库表会用）"></a>1.三大范式（设计数据库表会用）</h2><p>三大范式是 Mysql 数据库设计表结构所遵循的规范和指导方法，目的是为了减少冗余，建立结构合理的数据库，从而提高数据存储和使用的性能。</p><h3 id="1-1-第一范式"><a href="#1-1-第一范式" class="headerlink" title="1.1 第一范式"></a>1.1 第一范式</h3><p>遵循原子性，即<strong>表中字段数据，不可再分</strong></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014141600771.png" alt="image-20231014141600771"></p><p>姓名可再分</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014141653019.png" alt="image-20231014141653019"></p><h3 id="1-2-第二范式"><a href="#1-2-第二范式" class="headerlink" title="1.2 第二范式"></a>1.2 第二范式</h3><p>在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，<strong>表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</strong>再通俗点讲就是，<strong>一个表只能描述一件事情</strong>。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014141825547.png" alt="image-20231014141825547"></p><p>我们先分析一下表结构。</p><ol><li>假设学号是表中的唯一主键，那由学号就可以确定姓名和年龄了，但是却不能确定课程名称和成绩。</li><li>假设课程名称是表中的唯一主键，那由课程名称就可以确定学分了，但是却不能确定姓名、年龄和成绩。</li><li>虽然通过学号和课程名称的联合主键，可以确定除联合主键外的所有的非主键值，但是基于上述两个假设，也不符合第二范式的要求。</li></ol><p>我们可以<strong>基于上述的三种主键的可能，拆分成 3 张表，保证一张表只描述一件事情</strong>。</p><ol><li>学生表 - 学号做主键</li></ol><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142006760.png" alt="image-20231014142006760"></p><p>2.课程表 - 课程名称做主键</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142025456.png" alt="image-20231014142025456"></p><p>3.成绩表 - 学号和课程名称做联合主键</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142043835.png" alt="image-20231014142043835"></p><p>这时候我们可能会想，为什么我们就要遵循第二范式呢？<strong>不遵循第二范式会造成什么样的后果呢</strong>？</p><ol><li><strong>造成整表的数据冗余。</strong></li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li><strong>更新数据不方便。</strong></li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li><strong>插入数据不方便或产生异常。</strong></li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p><h3 id="1-3-第三范式"><a href="#1-3-第三范式" class="headerlink" title="1.3 第三范式"></a>1.3 第三范式</h3><p>在满足第二范式的情况下，消除传递依赖。即，<strong>在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B</strong>。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142159340.png" alt="image-20231014142159340"></p><p>这个表中，学号是主键，它可以唯一确定姓名、班级、班主任，符合了第二范式，但是在非主键字段中，我们也可以通过班级推导出该班级的班主任，所以它是不符合第三范式的。</p><p>那怎么设计表结构，才是符合第三范式的呢？</p><p>1.学生表</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142228435.png" alt="image-20231014142228435"></p><p>2.班级表</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142240158.png" alt="image-20231014142240158"></p><p>通过把班级与班主任的映射关系另外做成一张映射表，我们就成功地消除了表中的传递依赖了。</p><h2 id="2-数据库语言"><a href="#2-数据库语言" class="headerlink" title="2.数据库语言"></a>2.数据库语言</h2><p><strong>数据查询语言（DQL）：</strong>用来查询记录。保留字：select、where、order by、group by、having（where不能加聚合函数，通过having加，group by后面跟having）。</p><p><strong>数据操作语言（DML）：</strong>用来操纵数据库记录。保留字：insert、update、delete。</p><p><strong>数据定义语言（DDL）：</strong>用来定义数据库的表、库、列等对象。保留字：create、alter、drop、truncate</p><p><strong>数据控制语言（DCL）：</strong>用来定义访问权限和安全级别。保留字：commit，rollback、savepoint、grant、revoke</p><p>易考点：</p><p>1.delete ，delete from student order by math desc limit 3；标记为删除没真删，DML，用来删部分数据</p><p>2.truncate，truncate table_name ；DDL，本质是新建一个表结构并删除之前的，DDL，删除所有行数据</p><p>3.drop，drop table_name；DDL，本质是行数据+表结构一起删除</p><p>4.分页查询：select 字段名 from 表 limit 初始位置，记录条数</p><p>5.insert into std (id,name,score) values(xxxxxx)</p><p>6.delete from stu where</p><p>7.update stu set name&#x3D;xxx,where name&#x3D;xx</p><p>SQL语句的连接分为内连接、外连接</p><p>内连接：利用条件表达式来消除交叉连接，如果没有连接条件就和cross join一样，都是在笛卡尔积商上进行处理</p><p>外连接：分为左外连接、右外连接、全连接（mysql没有）</p><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3.索引"></a>3.索引</h2><h3 id="3-1-用户记录是如何存放的？（索引的引入）"><a href="#3-1-用户记录是如何存放的？（索引的引入）" class="headerlink" title="3.1 用户记录是如何存放的？（索引的引入）"></a>3.1 用户记录是如何存放的？（索引的引入）</h3><p>我们平时都是以记录为单位向MySQL的表中插入数据的，这些记录在磁盘中的存放的格式就是InnoDB的行格式。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151052208.png" alt="image-20231014151052208"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150256129.png" alt="image-20231014150256129"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150341549.png" alt="image-20231014150341549"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150548767.png" alt="image-20231014150548767"></p><p>最终数据页</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150707242.png" alt="image-20231014150707242"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150823780.png" alt="image-20231014150823780"></p><p>上图中的所有记录（包括伪记录）分成了4个小组，每个小组的“组长”被单独提拔，单独编制成“目录”，InnoDB官方称之为「<code>槽</code>」。槽在物理空间中是连续的，意味着通过一个槽可以很轻松地找到它的上一个和下一个，这一点非常重要。</p><p>槽的编号从0开始，我们查找数据的时候先找到对应的槽，然后再到小组中进行遍历即可，因为一个小组内的记录数量并不多，遍历的性能损耗可以忽略。而且每个槽代表的“组长”的主键值也是从小到大进行排列的，所以我们可以用二分法进行槽的快速查找。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150843962.png" alt="image-20231014150843962"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150955225.png" alt="image-20231014150955225"></p><p>当用户记录多到一个数据页装不下的时候，就再申请一个数据页，各个数据页在逻辑上使用双向链表进行连接，因此新分配的数据页编号就没必要非得按照从小到大的顺序进行排列了</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151137226.png" alt="image-20231014151137226"></p><p>这时，我们在在一个数据页内能够做到主键的快速查询，但是页号直接的快速查找就不可以了，我们就需要沿着双向链表一直进行查找，所有就引入了索引的概念</p><h3 id="3-2-B-树"><a href="#3-2-B-树" class="headerlink" title="3.2 B+树"></a>3.2 B+树</h3><p>现在一个页面的信息就是这样的</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151549941.png" alt="image-20231014151549941"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151610777.png" alt="image-20231014151610777"></p><p>进行添加数据页</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152041362.png" alt="image-20231014152041362"></p><p>最后变成</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152107958.png" alt="image-20231014152107958"></p><h4 id="3-2-1-聚簇索引"><a href="#3-2-1-聚簇索引" class="headerlink" title="3.2.1 聚簇索引"></a>3.2.1 聚簇索引</h4><p>这就是B+树，最底层的结点被称为<strong>叶子节点</strong>，剩下的就是<strong>非叶节点</strong>，这棵B+树的叶子节点存储了我们完整的用户记录（就是我们插入表的所有数据），而且，这是用户记录在InnoDB引擎中的唯一存储方式。也就是所谓的“<strong>索引即数据，数据即索引</strong>”。这个索引就是<strong>主键索引</strong>，又叫做<strong>聚簇索引</strong>。</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151838196.png" alt="image-20231014151838196"></p><h4 id="3-2-2-普通索引"><a href="#3-2-2-普通索引" class="headerlink" title="3.2.2 普通索引"></a>3.2.2 普通索引</h4><p>除了主键索引以外，我们还有<strong>普通索引</strong></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152530584.png" alt="image-20231014152530584"></p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152543616.png" alt="image-20231014152543616"></p><p>可以看到叶子节点存放的不再是完整的用户记录，而是只记录<code>name</code>列和主键值</p><p>数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照<code>name</code>列排序；</p><p>目录项记录除了存储索引列（<code>name</code>）和页号之外，同时还存储了主键值；</p><p><strong>普通索引查询</strong>时走如下方式</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152724393.png" alt="image-20231014152724393"></p><h4 id="3-2-3-联合索引"><a href="#3-2-3-联合索引" class="headerlink" title="3.2.3 联合索引"></a>3.2.3 联合索引</h4><p>先对name进行排序，然后name相同时再对age，可以看到name有序，age无序</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014153048054.png" alt="image-20231014153048054"></p><p>数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照<code>name</code>列排序，如果<code>name</code>列相同，那就按照<code>phone</code>列排序；</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014153109952.png" alt="image-20231014153109952"></p><p>最后回表查询</p><p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014153242173.png" alt="image-20231014153242173"></p><p>这也就解释了为什么索引是<strong>最左匹配原则</strong>，因为在底层的时候就是从左到右边按序排列的</p><h3 id="4-备注"><a href="#4-备注" class="headerlink" title="4.备注"></a>4.备注</h3><p>本文引用了知乎<a href="https://zhuanlan.zhihu.com/p/479164948">彻底搞懂MySQL的主键索引、普通索引和联合索引 - 知乎 (zhihu.com)</a>以及<a href="https://www.bilibili.com/video/BV1au4y1D7Qj/?spm_id_from=333.999.0.0&vd_source=0fb3165118535b2ba15fe8d267120151">动画演示：用最简单直白的方式讲解MySQL的主键索引、普通索引和联合索引_哔哩哔哩_bilibili</a>的讲解，图片非常清晰感兴趣的友友们可以去看</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP相关知识</title>
    <link href="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h1><h2 id="1-键入网址到网页显示"><a href="#1-键入网址到网页显示" class="headerlink" title="1.键入网址到网页显示"></a>1.键入网址到网页显示</h2><p>1.浏览器做的第一步工作是解析 URL，对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p><p>2.进行DNS解析（递归和迭代）：将域名解析成IP地址</p><p>3.通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>4.在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>5.TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><p>6.生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p><p>7.网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>8.交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>9.网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>10.数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>11.浏览器解析渲染页面</p><p>12.TCP四次挥手</p><h2 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2.HTTP报文"></a>2.HTTP报文</h2><h3 id="2-1-HTTP请求报文"><a href="#2-1-HTTP请求报文" class="headerlink" title="2.1 HTTP请求报文"></a>2.1 HTTP请求报文</h3><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012205223836.png" class title="image-20231012205223836"><p>真实数据</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210136196.png" class title="image-20231012210136196"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210300986.png" class title="image-20231012210300986"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210358855.png" class title="image-20231012210358855"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210644840.png" class title="image-20231012210644840"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211018848.png" class title="image-20231012211018848"><h3 id="2-2-HTTP响应报文"><a href="#2-2-HTTP响应报文" class="headerlink" title="2.2 HTTP响应报文"></a>2.2 HTTP响应报文</h3><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211123361.png" class title="image-20231012211123361"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211439888.png" class title="image-20231012211439888"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211513618.png" class title="image-20231012211513618"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211538145.png" class title="image-20231012211538145"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211801367.png" class title="image-20231012211801367"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211554409.png" class title="image-20231012211554409"><h2 id="3-HTTP和HTTPS的区别"><a href="#3-HTTP和HTTPS的区别" class="headerlink" title="3.HTTP和HTTPS的区别"></a>3.HTTP和HTTPS的区别</h2><p>HTTP 是一种 <code>超文本传输协议(Hypertext Transfer Protocol)</code>，<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012212923334.png" class title="image-20231012212923334"><p>而 HTTPS 的全称是 <code>Hypertext Transfer Protocol Secure</code>，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 <strong>HTTP + TLS&#x2F;SSL 协议</strong>组合而成，而安全性的保证正是 TLS&#x2F;SSL 所做的工作。</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012212954347.png" class title="image-20231012212954347"><p>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；</p><p>而 HTTPS 是安全的协议，它通过 <strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong> 能够解决上面这些问题。</p><p>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443</p><h2 id="4-HTTPS的工作原理"><a href="#4-HTTPS的工作原理" class="headerlink" title="4.HTTPS的工作原理"></a>4.HTTPS的工作原理</h2><p>我们探讨 HTTPS 的握手过程，其实就是 SSL&#x2F;TLS 的握手过程。</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012214122997.png" class title="image-20231012214122997"><h2 id="5-HTTP-Get和Post区别"><a href="#5-HTTP-Get和Post区别" class="headerlink" title="5.HTTP Get和Post区别"></a>5.HTTP Get和Post区别</h2><p>1.Get 方法一般用于请求，比如你在浏览器地址栏输入 <code>www.cxuanblog.com</code> 其实就是发送了一个 Get 请求，它的主要特征是请求服务器返回资源，而 Post 方法一般用于 <code>&lt;form&gt; 表单</code>的提交，相当于是把信息提交给服务器，等待服务器作出响应，Get 相当于一个是 pull&#x2F;拉的操作，而 Post 相当于是一个 push&#x2F;推的操作。</p><p>2.Get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造,post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p><p>3.Get 请求的 URL 有长度限制，而Post 请求会把参数和值放在消息体中，对数据长度没有要求。</p><p>4.Get 请求在发送过程中会产生一个 TCP 数据包；Post 在发送过程中会产生两个 TCP 数据包。对于 Get 方式的请求，浏览器会把 Gttp Header 和 Data 一并发送出去，服务器响应 200（返回数据）；而对于 Post，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送 Data，服务器响应 200 ok（返回数据）。</p><p>5.Post能发送更多的数据类型（Get只能发送ASCII字符）</p><h2 id="6-什么是无状态协议，HTTP-是无状态协议吗，怎么解决"><a href="#6-什么是无状态协议，HTTP-是无状态协议吗，怎么解决" class="headerlink" title="6.什么是无状态协议，HTTP 是无状态协议吗，怎么解决"></a>6.什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h2><p>无状态协议(Stateless Protocol) 就是指<strong>浏览器对于事务的处理没有记忆能力</strong>。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p><p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 <strong>小甜饼(Cookie)<strong>的机制。它能够让浏览器具有</strong>记忆</strong>能力。</p><p>当你想服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012215048011.png" class title="image-20231012215048011"><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012215809720.png" class title="image-20231012215809720"><p>7.Cookie与Session区别</p><p>(1) cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2) cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3) session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4) 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5) 所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p><h2 id="7-HTTP常见请求头"><a href="#7-HTTP常见请求头" class="headerlink" title="7.HTTP常见请求头"></a>7.HTTP常见请求头</h2><p>通用标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220255825.png" class title="image-20231012220255825"><p>实体标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220308488.png" class title="image-20231012220308488"><p>请求标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220321081.png" class title="image-20231012220321081"><p>响应标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220333020.png" class title="image-20231012220333020">]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>liunx-IO</title>
    <link href="/2023/10/10/liunx-IO/"/>
    <url>/2023/10/10/liunx-IO/</url>
    
    <content type="html"><![CDATA[<h1 id="Liunx-IO"><a href="#Liunx-IO" class="headerlink" title="Liunx-IO"></a>Liunx-IO</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><h3 id="1-1-Liunx的组成"><a href="#1-1-Liunx的组成" class="headerlink" title="1.1 Liunx的组成"></a>1.1 Liunx的组成</h3><p>如下图所示，Liunx系统包含了内核、Shell、文件系统、应用系统</p><img src="/2023/10/10/liunx-IO/image-20231010223007225.png" class title="image-20231010223007225"><p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p><p><strong>系统调用接口：</strong>SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p><img src="/2023/10/10/liunx-IO/image-20231010223213876.png" class title="image-20231010223213876"><h3 id="1-2-用户空间与内核空间"><a href="#1-2-用户空间与内核空间" class="headerlink" title="1.2 用户空间与内核空间"></a>1.2 用户空间与内核空间</h3><p>对于Linux操作系统而言，其核心是内核，内核独立于普通的应用程序。操作系统为了支持多个应用同时进行，需保证不同进程之间的相对独立（一个进程崩溃不会影响其他进程，恶意进程不能直接读取或修改其他进程运行时的代码或数据）。因此操作系统内核需要用有比普通进程更高的权限，以此来调度和管理用户的应用程序，同时也可以保证内核的安全。</p><p>因此内存空间被划分为内核空间、用户空间。内核可以访问受保护的内核空间，也有访问底层硬件设备的所有权限。</p><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><img src="/2023/10/10/liunx-IO/image-20231010223620882.png" class title="image-20231010223620882"><h3 id="1-3-进程切换"><a href="#1-3-进程切换" class="headerlink" title="1.3 进程切换"></a>1.3 进程切换</h3><p>为了管理进程，内核必须有挂起、恢复某个进程的能力。此种行为称为上下文切换。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">保存CPU上下文信息，包括程序计数器、其他寄存器<br>更新PCB信息<br>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列<br>选择另一个进程执行，并更新其PCB<br>更新内存管理的数据结构<br></code></pre></td></tr></table></figure><p>总结：上下文切换需要进行一系列复杂的操作，很消耗资源</p><h3 id="1-4-进程的阻塞"><a href="#1-4-进程的阻塞" class="headerlink" title="1.4 进程的阻塞"></a>1.4 进程的阻塞</h3><p><strong>正在执行的进程，当它无法获取到所需的资源（比如请求系统资源失败、等待某种操作完成、新数据尚未到达或无新的工作任务），则由系统执行阻塞原语（Block），使自己由运行状态变为阻塞状态。</strong> 只有处于运行态的进程才可能将其转为阻塞状态。阻塞态的进程不占用CPU资源。</p><h3 id="1-5-文件与文件描述符"><a href="#1-5-文件与文件描述符" class="headerlink" title="1.5 文件与文件描述符"></a>1.5 文件与文件描述符</h3><p>Linux中一切皆文件，包括普通文件、套接字、字符设备文件（键盘、鼠标等等）、块设备文件（光驱、硬盘），这些都抽象成文件</p><p>文件描述符，File Descriptor，简称fd。其本质是一个非负整数。当程序打开或创建一个文件，内核都会返回一个非负整数，即文件描述符。此非负整数对应内核为每个进程所维护的该进程打开文件的记录表中的一条记录，即非负整数对应一个表上的一条记录。如下图所示：</p><img src="/2023/10/10/liunx-IO/image-20231010224322534-1697161520610-5.png" class title="image-20231010224322534"><p>如上图所示，进程A中文件描述符1和3都指向同一个句柄13，这可能是该进程A多次执行打开同一个文件操作。</p><p>总结：进程拿到文件描述符，去进程对应的文件描述符表查询到文件指针，文件指针指向系统级别的打开文件表的文件偏移量，通过文件偏移量拿到i-node指针，最终找到真实的文件。</p><p><strong>小结：</strong></p><p>当用户打开一个文件，用户只得到了一个 <code>fd</code> 句柄，但内核做了很多事情，梳理下来，我们得到几个关键的数据结构，这几个数据结构是有层次递进关系的，我们简单梳理下：</p><ol><li>进程结构 <code>task_struct</code> ：表征进程实体，每一个进程都和一个 <code>task_struct</code> 结构体对应，其中 <code>task_struct.files</code> 指向一个管理打开文件的结构体 <code>fiels_struct</code> ；</li><li>文件表项管理结构 <code>files_struct</code> ：用于管理进程打开的 open 文件列表，内部以数组的方式实现（静态数组和动态数组结合）。返回给用户的 <code>fd</code> 就是这个数组的<strong>编号索引</strong>而已，索引元素为 <code>file</code> 结构；</li></ol><ul><li><strong><code>files_struct</code> 只从属于某进程；</strong></li></ul><p>​文件 <code>file</code> 结构：表征一个打开的文件，内部包含关键的字段有：<strong>当前文件偏移，inode 结构地址</strong>；</p><ul><li><strong>该结构虽然由进程触发创建，但是 <code>file</code> 结构可以在进程间共享；</strong></li></ul><p>​<code>vfs inode</code> 结构体：文件 <code>file</code> 结构指向 的是 vfs 的 <code>inode</code> ，这个是操作系统抽象出来的一层，用于屏蔽后端各种各样的文件系统的 <code>inode</code> 差异；</p><ul><li><strong>inode 这个具体进程无关，是文件系统级别的资源；</strong></li></ul><p>​<code>ext4 inode</code> 结构体（指代具体文件系统 inode ）：后端文件系统的 <code>inode</code> 结构，不同文件系统自定义的结构体，ext2 有 <code>ext2_inode_info</code>，ext4 有<code>ext4_inode_info</code>，minix 有 <code>minix_inode_info</code>，这些结构里都是内嵌了一个 vfs <code>inode</code> 结构体，原理相同；</p><img src="/2023/10/10/liunx-IO/image-20231010224514222-1697161551998-7.png" class title="image-20231010224514222"><p><strong>Liunx内核的VFS子系统</strong></p><img src="/2023/10/10/liunx-IO/image-20231010225314350.png" class title="image-20231010225314350"><p>​文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。</p><p>​在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是<strong>对应不同的file结构体，因此可以有不同的File Status Flag和读写位置</strong>。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。</p><p>​每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。</p><p>​file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p><p>​每个file结构体都有一个指向dentry结构体的指针，<strong>“dentry”是directory entry（目录项）的缩写</strong>。我们传给open、stat等函数的参数的是一个路径，例如&#x2F;home&#x2F;akaedu&#x2F;a，需要根据路径找到文件的inode。<strong>为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache</strong>，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录&#x2F;找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p><p>​每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示&#x2F;home&#x2F;akaedu&#x2F;a和&#x2F;home&#x2F;akaedu&#x2F;b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。</p><p>​和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。</p><p>​inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到&#x2F;home目录下。</p><p>​file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p><h3 id="1-6-缓存IO"><a href="#1-6-缓存IO" class="headerlink" title="1.6 缓存IO"></a>1.6 缓存IO</h3><p>缓存IO又被称作标准IO，在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中（page cache）。即数据先被拷贝到内核的缓冲区中，随后才会被拷贝到应用程序的地址空间。</p><p>优点：可以解决CPU与IO速度冲突问题</p><p>缺点：数据传输过程中，数据在进程的<strong>地址空间与内核空间进行多次数据拷贝操作</strong>，CPU以及内存开销都很大。</p><p>总结：网络IO就是操作系统接收网卡收到的数据，缓存到一个buffer中，应用程序调用操作系统的函数（就是操作系统提供的IO接口），从对应的buffer中取出数据。操作系统在网络IO过程中充当了一个提供抽象接口的角色</p><h2 id="2-Liunx-IO模型"><a href="#2-Liunx-IO模型" class="headerlink" title="2.Liunx IO模型"></a>2.Liunx IO模型</h2><p>网络IO的本质是socket的读取，socket会被Linux抽象成流，IO可以看作是对流的操作。以Read举例子，对于一次IO访问，<strong>数据先被拷贝到内核的缓冲区中，然后才从操作系统内核的缓冲区中拷贝到应用程序的地址空间</strong>。</p><p>当发生一次Read操作时，会发生以下2个阶段：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">等待数据准备<br>将数据从内核拷贝到进程中<br></code></pre></td></tr></table></figure><p>对于Socket流而言，发生如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">通常等待网络上其他数据分组到达，然后被复制到内核的某个缓冲区中<br>把数据从内核的缓冲区复制到应用进程缓冲区<br></code></pre></td></tr></table></figure><p>网络IO有如下几种：</p><ul><li>同步模型（synchronous IO）</li><li>阻塞IO（blocking IO）</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li><li>异步IO（asynchronous IO）</li></ul><h3 id="2-1-同步阻塞IO"><a href="#2-1-同步阻塞IO" class="headerlink" title="2.1 同步阻塞IO"></a>2.1 同步阻塞IO</h3><p>用户空间的进程执行一个系统调用，比如recvfrom，这会导致应用程序阻塞，期间什么都不干，直到数据准备好，并且数据被从内核缓冲区复制到用户进程</p><img src="/2023/10/10/liunx-IO/image-20231011093416174.png" class title="image-20231011093416174"><p>如上图所示，用户进程调用recvfrom这个系统调用，内核即开始IO的第一个阶段，对于网络IO来说，此时还未收到一个完整的数据包，通常需要等待其他数据报到来组成一个完整的数据包。这个过程是数据被复制到内核的某个缓冲区中。此时用户进程会自行阻塞。复制完后，进入第二个阶段。<strong>内核一直等到数据准备好了</strong>，就把数据从内核复制到用户空间。内核返回结果，用户进程解除阻塞状态，重新运行起来。</p><img src="/2023/10/10/liunx-IO/image-20231011111441664.png" class title="image-20231011111441664"><h3 id="2-2-同步非阻塞IO"><a href="#2-2-同步非阻塞IO" class="headerlink" title="2.2 同步非阻塞IO"></a>2.2 同步非阻塞IO</h3><p>用户进程调用recvfrom系统调用，进程没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时返回一个error。进程收到返回后做些别的事请，过一会再发起recvfrom系统调用。如此循环重复，此过程常称为轮询。直到数据准备好并且已经被复制到用户空间。如下图所示：</p><img src="/2023/10/10/liunx-IO/image-20231011095934835.png" class title="image-20231011095934835"><p>用户进程发出recvfrom操作，用户进程不会被阻塞，内核若还未准备好数据，则会返回一个error。<strong>此时用户进程可以干别的事请，过一会再调用recvfrom询问内核是否准备好了数据，此操作称为轮询</strong>。一旦内核准备好了数据并且用户进程前来询问，此时内核将数据复制到用户空间中并且返回。</p><h3 id="2-3-IO多路复用"><a href="#2-3-IO多路复用" class="headerlink" title="2.3 IO多路复用"></a>2.3 IO多路复用</h3><p>同步非阻塞IO是由用户进程去轮询内核是否准备好了数据。IO多路复用则使用<strong>一个特定的进程去轮询</strong>。这就是IO多路复用。常见的select、poll、epoll就是干这个的。select调用是内核级别的。select与同步非阻塞的区别在于：前者能等待多个socket，即能同时监听多个IO端口。当内核对任何一个socket准备好了部分数据（select无需等所有数据包到达内核后才开始，内核会负责监视是否有数据到达）就能返回，然后用户进程再进行recvfrom调用，将数据从内核复制到用户空间。</p><p>select、poll、epoll可以同时阻塞多个IO操作。直到内核监视到有数据到达内核，才真正调用IO操作函数。</p><img src="/2023/10/10/liunx-IO/image-20231011103101687.png" class title="image-20231011103101687"><p>IO multiplexing就是常说的select、poll、epoll。好处是用一个进程即可处理多个网络连接的IO。其原理是select、poll、epoll不断地轮询负责的socket，当某个socket有数据到达内核，就通知用户进程。</p><p>用户进程调用select，整个进程会被阻塞。内核监视select负责的所有socket，任何一个有数据准备好，select就返回。此时用户再调用recvfrom，将数据从内核拷贝到用户进程。</p><h4 id="2-3-1-select原理"><a href="#2-3-1-select原理" class="headerlink" title="2.3.1 select原理"></a><strong>2.3.1 select原理</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds,                     <span class="hljs-comment">// 监控的文件描述符集里最大文件描述符加1</span></span><br><span class="hljs-params">    fd_set *readfds,              <span class="hljs-comment">// 监控有读数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *writefds,             <span class="hljs-comment">// 监控写数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *exceptfds,            <span class="hljs-comment">// 监控异常发生达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout)</span>;     <span class="hljs-comment">// 定时阻塞监控时间</span><br></code></pre></td></tr></table></figure><p>readfds、writefds、errorfds 是三个文件描述符集合。select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换这三个引用参数中的对应集合，返回所有就绪描述符的数量。</p><p>timeout 参数表示调用 select 时的阻塞时长。如果所有 fd 文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。</p><p><strong>fd_set 文件描述符集合</strong></p><p>select 函数参数中的 fd_set 类型表示文件描述符的集合。</p><p>由于文件描述符 fd 是一个从 0 开始的无符号整数，所以可以使用 fd_set 的二进制每一位来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 fd_set 长度为 1 字节，则一个 fd_set 变量最大可以表示 8 个文件描述符。当 select 返回 fd_set &#x3D; 00010011 时，表示文件描述符 1、2、5 已经就绪。</p><img src="/2023/10/10/liunx-IO/image-20231011112434243.png" class title="image-20231011112434243"><img src="/2023/10/10/liunx-IO/image-20231011213646817.png" class title="image-20231011213646817"><h4 id="2-3-2-epoll实现原理"><a href="#2-3-2-epoll实现原理" class="headerlink" title="2.3.2 epoll实现原理"></a>2.3.2 epoll实现原理</h4><p>epoll 的特点是：</p><p>1）使用<strong>红黑树</strong>存储<strong>一份</strong>文件描述符集合，每个文件描述符只需在添加时传入一次，无需用户每次都重新传入；—— 解决了 select 中 fd_set 重复拷贝到内核的问题</p><p>2）通过异步 IO 事件找到就绪的文件描述符，而不是通过轮询的方式；</p><p>3）使用队列存储就绪的文件描述符，且会按需返回就绪的文件描述符，无须再次遍历；</p><p><strong>epoll_ctl</strong></p><p>epoll_ctl 函数主要负责把服务端和客户端建立的 socket 连接注册到 eventpoll 对象里，会做三件事：</p><p>1）创建一个 epitem 对象，主要包含两个字段，分别存放 socket fd 即连接的文件描述符，和所属的 eventpoll 对象的指针；</p><p>2）将一个数据到达时用到的回调函数添加到 socket 的进程等待队列中，注意，跟第 1.1 节的阻塞 IO 模式不同的是，这里添加的 socket 的进程等待队列结构中，只有回调函数，没有设置进程描述符，因为<strong>在 epoll 中，进程是放在 eventpoll 的等待队列中</strong>，等待被 epoll_wait 函数唤醒，而不是放在 socket 的进程等待队列中；</p><p>3）将第 1）步创建的 epitem 对象插入红黑树；</p><img src="/2023/10/10/liunx-IO/image-20231011215103788.png" class title="image-20231011215103788"><p><strong>epoll_wait</strong></p><p>epoll_wait 函数的动作比较简单，检查 eventpoll 对象的就绪的连接 rdllist 上是否有数据到达，如果没有就把当前的进程描述符添加到一个等待队列项里，加入到 eventpoll 的进程等待队列里，然后阻塞当前进程，等待数据到达时通过回调函数被唤醒。</p><p>当 eventpoll 监控的连接上有数据到达时，通过下面几个步骤唤醒对应的进程处理数据：</p><p>1）socket 的数据接收队列有数据到达，会通过进程等待队列的回调函数 ep_poll_callback 唤醒红黑树中的节点 epitem；</p><p>2）ep_poll_callback 函数将有数据到达的 epitem 添加到 eventpoll 对象的就绪队列 rdllist 中；</p><p>3）ep_poll_callback 函数检查 eventpoll 对象的进程等待队列上是否有等待项，通过回调函数 default_wake_func 唤醒这个进程，进行数据的处理；</p><p>4）当进程醒来后，继续从 epoll_wait 时暂停的代码继续执行，把 rdlist 中就绪的事件返回给用户进程，让用户进程调用 recv 把已经到达内核 socket 等待队列的数据拷贝到用户空间使用。</p><img src="/2023/10/10/liunx-IO/image-20231011220001774.png" class title="image-20231011220001774"><h4 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3 总结"></a>2.3.3 总结</h4><p>从阻塞 IO 到 epoll 的实现中，我们可以看到 <strong>wake up 回调函数机制</strong>被频繁的使用，至少有三处地方：一是阻塞 IO 中数据到达 socket 的等待队列时，通过回调函数唤醒进程，二是 epoll 中数据到达 socket 的等待队列时，通过回调函数 ep_poll_callback 找到 eventpoll 中红黑树的 epitem 节点，并将其加入就绪列队 rdllist，三是通过回调函数 default_wake_func 唤醒用户进程 ，并将 rdllist 传递给用户进程，让用户进程准确读取数据 。从中可知，这种回调机制能够定向准确的通知程序要处理的事件，而不需要每次都循环遍历检查数据是否到达以及数据该由哪个进程处理，提高了程序效率，在日常的业务开发中，我们也可以借鉴下这一机制。</p><h3 id="2-4-信号驱动式IO"><a href="#2-4-信号驱动式IO" class="headerlink" title="2.4 信号驱动式IO"></a>2.4 信号驱动式IO</h3><img src="/2023/10/10/liunx-IO/image-20231012105822167.png" class title="image-20231012105822167"><h3 id="2-5-异步IO"><a href="#2-5-异步IO" class="headerlink" title="2.5 异步IO"></a>2.5 异步IO</h3><img src="/2023/10/10/liunx-IO/image-20231012105909004.png" class title="image-20231012105909004"><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p><strong>同步：</strong>发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 例如：B&#x2F;S模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。</p><p><strong>异步：</strong>异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>对于通知调用者的三种方式，具体如下：</p><ul><li>状态</li></ul><p>即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p><ul><li>通知</li></ul><p>当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p><ul><li>回调</li></ul><p>与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p><p>例如：B&#x2F;S模式中的ajax请求，具体过程是：客户端发出ajax请求-&gt;服务端处理-&gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。</p><p><strong>总结来说，同步和异步的区别：请求发出后，是否需要等待结果，才能继续执行其他操作。</strong></p><p><strong>阻塞：</strong>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p><strong>非阻塞：</strong>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>总体来说：阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</strong></p><p><strong>同步阻塞</strong>：小明一直盯着下载进度条，到 100% 的时候就完成。 - 同步体现在：等待下载完成通知。 - 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理。</p><p><strong>同步非阻塞</strong>：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。 - 同步体现在：等待下载完成通知。 - 非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条。【小明必须要在两个任务间切换，关注下载进度】</p><p><strong>异步阻塞</strong>：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明不做别的事，仍然一直等待“叮”的声音。 - 异步体现在：下载完成“叮”一声通知。 - 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理。</p><p><strong>异步非阻塞</strong>：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 - 异步体现在：下载完成“叮”一声通知。 - 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-liunx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>liunx命令</title>
    <link href="/2023/10/08/liunx%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/10/08/liunx%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="liunx命令"><a href="#liunx命令" class="headerlink" title="liunx命令"></a>liunx命令</h1><h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1.文件结构"></a>1.文件结构</h2><table><thead><tr><th>文件</th><th align="left">描述</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td align="left">二进制文件</td></tr><tr><td>&#x2F;boot</td><td align="left">系统启动分区</td></tr><tr><td>&#x2F;dev</td><td align="left">设备文件</td></tr><tr><td>&#x2F;etc</td><td align="left">大多数配置文件</td></tr><tr><td>&#x2F;home</td><td align="left">普通用户的家目录</td></tr><tr><td>&#x2F;lib</td><td align="left">32位函数库</td></tr><tr><td>&#x2F;lib64</td><td align="left">64位库</td></tr><tr><td>&#x2F;media</td><td align="left">手动临时挂载点</td></tr><tr><td>&#x2F;mnt</td><td align="left">手动临时挂载点</td></tr><tr><td>&#x2F;opt</td><td align="left">第三方软件安装位置</td></tr><tr><td>&#x2F;proc</td><td align="left">进程信息及硬件信息</td></tr><tr><td>&#x2F;sbin</td><td align="left">系统管理命令</td></tr><tr><td>&#x2F;srv</td><td align="left">数据</td></tr><tr><td>&#x2F;var</td><td align="left">数据</td></tr><tr><td>&#x2F;sys</td><td align="left">内核相关信息</td></tr><tr><td>&#x2F;tmp</td><td align="left">临时文件</td></tr><tr><td>&#x2F;usr</td><td align="left">用户相关设定</td></tr></tbody></table><h2 id="2-命令行含义"><a href="#2-命令行含义" class="headerlink" title="2.命令行含义"></a>2.命令行含义</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">示例：root@app00:~# <br>root    //用户名，root为超级用户<br>@       //分隔符<br>app00   //主机名称<br>~       //当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下）<br><span class="hljs-meta prompt_"># </span><span class="language-bash">     //表示当前用户是超级用户，普通用户为$，例如：（<span class="hljs-string">&quot;yao@app00:/root$&quot;</span> ，表示使用用户<span class="hljs-string">&quot;yao&quot;</span>访问/root文件夹）</span><br></code></pre></td></tr></table></figure><h2 id="3-目录操作"><a href="#3-目录操作" class="headerlink" title="3.目录操作"></a>3.目录操作</h2><h3 id="3-1-切换目录（cd）"><a href="#3-1-切换目录（cd）" class="headerlink" title="3.1 切换目录（cd）"></a>3.1 切换目录（cd）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /                 //切换到根目录<br>cd /bin              //切换到根目录下的bin目录<br>cd ../               //切换到上一级目录 或者使用命令：cd ..<br>cd ~                 //切换到home目录<br>cd -                 //切换到上次访问的目录<br>cd xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错<br>cd /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全<br></code></pre></td></tr></table></figure><h3 id="3-2-查看目录（ls）"><a href="#3-2-查看目录（ls）" class="headerlink" title="3.2 查看目录（ls）"></a>3.2 查看目录（ls）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls                   //查看当前目录下的所有目录和文件<br>ls -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令&quot;ll&quot;效果一样<br>ls /bin              //查看指定目录下的所有目录和文件 <br></code></pre></td></tr></table></figure><h3 id="3-3-创建目录（mkdir）"><a href="#3-3-创建目录（mkdir）" class="headerlink" title="3.3 创建目录（mkdir）"></a>3.3 创建目录（mkdir）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir tools          //在当前目录下创建一个名为tools的目录<br>mkdir /bin/tools     //在指定目录下创建一个名为tools的目录<br></code></pre></td></tr></table></figure><h3 id="3-4-修改目录（mv"><a href="#3-4-修改目录（mv" class="headerlink" title="3.4  修改目录（mv)"></a>3.4  修改目录（mv)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 当前目录名 新目录名        //修改目录名，同样适用与文件操作<br>mv /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面<br>mv -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹<br></code></pre></td></tr></table></figure><h3 id="3-5-删除目录与文件（rm）"><a href="#3-5-删除目录与文件（rm）" class="headerlink" title="3.5 删除目录与文件（rm）"></a>3.5 删除目录与文件（rm）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名              //删除当前目录下的文件<br>rm -f 文件名           //删除当前目录的的文件（不询问）<br>rm -r 文件夹名         //递归删除当前目录下此名的目录<br>rm -rf 文件夹名        //递归删除当前目录下此名的目录（不询问）<br>rm -rf *              //将当前目录下的所有目录和文件全部删除<br>rm -rf /*             //将根目录下的所有文件全部删除【慎用！相当于格式化系统】<br></code></pre></td></tr></table></figure><h3 id="3-6-拷贝目录（cp）"><a href="#3-6-拷贝目录（cp）" class="headerlink" title="3.6 拷贝目录（cp）"></a>3.6 拷贝目录（cp）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面<br>cp -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹<br></code></pre></td></tr></table></figure><h3 id="3-7-搜索目录（find）"><a href="#3-7-搜索目录（find）" class="headerlink" title="3.7 搜索目录（find）"></a>3.7 搜索目录（find）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /bin -name &#x27;a*&#x27;        //查找/bin目录下的所有以a开头的文件或者目录<br></code></pre></td></tr></table></figure><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h2><h3 id="4-1-新增文件（touch）"><a href="#4-1-新增文件（touch）" class="headerlink" title="4.1 新增文件（touch）"></a>4.1 新增文件（touch）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch  a.txt         //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间<br>vim a.txt<br>cat &lt; daygeek4.txt<br></code></pre></td></tr></table></figure><h3 id="4-2-删除文件（rm）"><a href="#4-2-删除文件（rm）" class="headerlink" title="4.2 删除文件（rm）"></a>4.2 删除文件（rm）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名              //删除当前目录下的文件<br>rm -f 文件名           //删除当前目录的的文件（不询问）<br></code></pre></td></tr></table></figure><h3 id="4-3-编辑文件（vi、vim）"><a href="#4-3-编辑文件（vi、vim）" class="headerlink" title="4.3 编辑文件（vi、vim）"></a>4.3 编辑文件（vi、vim）</h3><h3 id="4-4-查看文件-tail、cat、less、more"><a href="#4-4-查看文件-tail、cat、less、more" class="headerlink" title="4.4 查看文件(tail、cat、less、more)"></a>4.4 查看文件(tail、cat、less、more)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.txt          //查看文件最后一屏内容<br>less a.txt         //PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看<br>more a.txt         //显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看<br>tail -100 a.txt    //查看文件的后100行，&quot;Ctrl+C&quot;退出查看<br></code></pre></td></tr></table></figure><h2 id="5-文件权限"><a href="#5-文件权限" class="headerlink" title="5.文件权限"></a>5.文件权限</h2><h3 id="5-1-权限说明"><a href="#5-1-权限说明" class="headerlink" title="5.1 权限说明"></a>5.1 权限说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">文件权限简介：&#x27;r&#x27; 代表可读（4），&#x27;w&#x27; 代表可写（2），&#x27;x&#x27; 代表执行权限（1），括号内代表&quot;8421法&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#文件权限信息示例：-rwxrw-r--</span></span><br>-第一位：&#x27;-&#x27;就代表是文件，&#x27;d&#x27;代表是文件夹<br>-第一组三位：拥有者的权限<br>-第二组三位：拥有者所在的组，组员的权限<br>-第三组三位：代表的是其他用户的权限<br></code></pre></td></tr></table></figure><h3 id="5-2-文件权限"><a href="#5-2-文件权限" class="headerlink" title="5.2 文件权限"></a>5.2 文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">普通授权    chmod +x a.txt    <br>8421法     chmod 777 a.txt     //1+2+4=7，&quot;7&quot;说明授予所有权限<br></code></pre></td></tr></table></figure><h2 id="6-打包与解压（tar）"><a href="#6-打包与解压（tar）" class="headerlink" title="6.打包与解压（tar）"></a>6.打包与解压（tar）</h2><h3 id="6-1-说明"><a href="#6-1-说明" class="headerlink" title="6.1 说明"></a>6.1 说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.zip、.rar        //windows系统中压缩文件的扩展名<br>.tar              //Linux中打包文件的扩展名<br>.gz               //Linux中压缩文件的扩展名<br>.tar.gz           //Linux中打包并压缩文件的扩展名<br></code></pre></td></tr></table></figure><h3 id="6-2-打包文件"><a href="#6-2-打包文件" class="headerlink" title="6.2 打包文件"></a>6.2 打包文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf 打包压缩后的文件名 要打包的文件<br>参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;<br>示例：<br>tar -zcvf a.tar file1 file2,...      //多个文件压缩打包<br></code></pre></td></tr></table></figure><h3 id="6-3-解压文件"><a href="#6-3-解压文件" class="headerlink" title="6.3 解压文件"></a>6.3 解压文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf a.tar                      //解包至当前目录<br>tar -zxvf a.tar -C /usr------        //指定解压的位置<br>unzip test.zip             //解压*.zip文件 <br>unzip -l test.zip          //查看*.zip文件的内容 <br></code></pre></td></tr></table></figure><h2 id="7-其他常用命令"><a href="#7-其他常用命令" class="headerlink" title="7. 其他常用命令"></a>7. 其他常用命令</h2><h3 id="7-1-find"><a href="#7-1-find" class="headerlink" title="7.1 find"></a>7.1 find</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*.c&quot;     //将目前目录及其子目录下所有延伸档名是 c 的文件列出来<br>find . -type f         //将目前目录其其下子目录中所有一般文件列出<br>find . -ctime -20      //将目前目录及其子目录下所有最近 20 天内更新过的文件列出<br>find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;     //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们<br>find . -type f -perm 644 -exec ls -l &#123;&#125; \;       //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br>find / -type f -size 0 -exec ls -l &#123;&#125; \;         //为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br></code></pre></td></tr></table></figure><h3 id="7-2-whereis"><a href="#7-2-whereis" class="headerlink" title="7.2 whereis"></a>7.2 whereis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whereis ls             //将和ls文件相关的文件都查找出来<br></code></pre></td></tr></table></figure><h3 id="7-3-grep"><a href="#7-3-grep" class="headerlink" title="7.3 grep"></a>7.3 grep</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -i &quot;the&quot; demo_file              //在文件中查找字符串(不区分大小写)<br>grep -A 3 -i &quot;example&quot; demo_text     //输出成功匹配的行，以及该行之后的三行<br>grep -r &quot;ramesh&quot; *                   //在一个文件夹中递归查询包含指定字符串的文件<br></code></pre></td></tr></table></figure><h3 id="7-4-free"><a href="#7-4-free" class="headerlink" title="7.4 free"></a>7.4 free</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">说明：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况 <br>free -g            //以G为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节 <br>free -t            //查看所有内存的汇总<br></code></pre></td></tr></table></figure><h3 id="7-5-top"><a href="#7-5-top" class="headerlink" title="7.5 top"></a>7.5 top</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top               //显示当前系统中占用资源最多的一些进程, shift+m 按照内存大小查看<br></code></pre></td></tr></table></figure><h3 id="7-6-df"><a href="#7-6-df" class="headerlink" title="7.6 df"></a>7.6 df</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">说明：显示文件系统的磁盘使用情况<br>df -h            //一种易看的显示<br></code></pre></td></tr></table></figure><h3 id="7-7-ssh"><a href="#7-7-ssh" class="headerlink" title="7.7 ssh"></a>7.7 ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@remote -p port<br>//user 是你在远程机器上的用户名，如果不指定的话默认为当前用户<br>//remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名<br>//port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22<br></code></pre></td></tr></table></figure><h3 id="7-8-scp"><a href="#7-8-scp" class="headerlink" title="7.8 scp"></a>7.8 scp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /opt/data.txt  192.168.1.101:/opt/    //将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下<br></code></pre></td></tr></table></figure><h3 id="7-9-查看进程"><a href="#7-9-查看进程" class="headerlink" title="7.9 查看进程"></a>7.9 查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef         //查看所有正在运行的进程<br></code></pre></td></tr></table></figure><h3 id="7-10-结束进程"><a href="#7-10-结束进程" class="headerlink" title="7.10 结束进程"></a>7.10 结束进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill pid       //杀死该pid的进程<br>kill -9 pid    //强制杀死该进程   <br></code></pre></td></tr></table></figure><h3 id="7-11-查看链接"><a href="#7-11-查看链接" class="headerlink" title="7.11 查看链接"></a>7.11 查看链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping IP        //查看与此IP地址的连接情况<br>netstat -an    //查看当前系统端口<br>netstat -an | grep 8080     //查看指定端口<br></code></pre></td></tr></table></figure><h3 id="7-12-查看网络"><a href="#7-12-查看网络" class="headerlink" title="7.12 查看网络"></a>7.12 查看网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h2 id="8-实用命令"><a href="#8-实用命令" class="headerlink" title="8.实用命令"></a>8.实用命令</h2><p>看8080端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nap|grep :8080   <br>//结果分别为：<br>协议名-网络接受队列-网络发送队列-本地地址-外部地址-链路状态-进程ip/应用程序<br></code></pre></td></tr></table></figure><p>强制杀死所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 `ps -aux|awk &#x27;&#123;print $2&#125;&#x27;`<br></code></pre></td></tr></table></figure><p>忽略大小写匹配a的行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -o -i &#x27;a&#x27; aaa.txt|wc -l<br></code></pre></td></tr></table></figure><p>查找最后500行日志的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Tail -n 500 文件名<br></code></pre></td></tr></table></figure><p>grep擅长查找，sed擅长修改文件、awk擅长取列</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-liunx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/08/hello-world/"/>
    <url>/2023/10/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
