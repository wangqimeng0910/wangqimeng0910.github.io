<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>liunx-IO</title>
    <link href="/2023/10/10/liunx-IO/"/>
    <url>/2023/10/10/liunx-IO/</url>
    
    <content type="html"><![CDATA[<h1 id="Liunx-IO"><a href="#Liunx-IO" class="headerlink" title="Liunx-IO"></a>Liunx-IO</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><h3 id="1-1-Liunx的组成"><a href="#1-1-Liunx的组成" class="headerlink" title="1.1 Liunx的组成"></a>1.1 Liunx的组成</h3><p>如下图所示，Liunx系统包含了内核、Shell、文件系统、应用系统</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231010223007225.png" alt="image-20231010223007225"></p><p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p><p><strong>系统调用接口：</strong>SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231010223213876.png" alt="image-20231010223213876"></p><h3 id="1-2-用户空间与内核空间"><a href="#1-2-用户空间与内核空间" class="headerlink" title="1.2 用户空间与内核空间"></a>1.2 用户空间与内核空间</h3><p>对于Linux操作系统而言，其核心是内核，内核独立于普通的应用程序。操作系统为了支持多个应用同时进行，需保证不同进程之间的相对独立（一个进程崩溃不会影响其他进程，恶意进程不能直接读取或修改其他进程运行时的代码或数据）。因此操作系统内核需要用有比普通进程更高的权限，以此来调度和管理用户的应用程序，同时也可以保证内核的安全。</p><p>因此内存空间被划分为内核空间、用户空间。内核可以访问受保护的内核空间，也有访问底层硬件设备的所有权限。</p><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231010223620882.png" alt="image-20231010223620882"></p><h3 id="1-3-进程切换"><a href="#1-3-进程切换" class="headerlink" title="1.3 进程切换"></a>1.3 进程切换</h3><p>为了管理进程，内核必须有挂起、恢复某个进程的能力。此种行为称为上下文切换。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">保存CPU上下文信息，包括程序计数器、其他寄存器<br>更新PCB信息<br>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列<br>选择另一个进程执行，并更新其PCB<br>更新内存管理的数据结构<br></code></pre></td></tr></table></figure><p>总结：上下文切换需要进行一系列复杂的操作，很消耗资源</p><h3 id="1-4-进程的阻塞"><a href="#1-4-进程的阻塞" class="headerlink" title="1.4 进程的阻塞"></a>1.4 进程的阻塞</h3><p><strong>正在执行的进程，当它无法获取到所需的资源（比如请求系统资源失败、等待某种操作完成、新数据尚未到达或无新的工作任务），则由系统执行阻塞原语（Block），使自己由运行状态变为阻塞状态。</strong> 只有处于运行态的进程才可能将其转为阻塞状态。阻塞态的进程不占用CPU资源。</p><h3 id="1-5-文件与文件描述符"><a href="#1-5-文件与文件描述符" class="headerlink" title="1.5 文件与文件描述符"></a>1.5 文件与文件描述符</h3><p>Linux中一切皆文件，包括普通文件、套接字、字符设备文件（键盘、鼠标等等）、块设备文件（光驱、硬盘），这些都抽象成文件</p><p>文件描述符，File Descriptor，简称fd。其本质是一个非负整数。当程序打开或创建一个文件，内核都会返回一个非负整数，即文件描述符。此非负整数对应内核为每个进程所维护的该进程打开文件的记录表中的一条记录，即非负整数对应一个表上的一条记录。如下图所示：</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231010224322534.png" alt="image-20231010224322534"></p><p>如上图所示，进程A中文件描述符1和3都指向同一个句柄13，这可能是该进程A多次执行打开同一个文件操作。</p><p>总结：进程拿到文件描述符，去进程对应的文件描述符表查询到文件指针，文件指针指向系统级别的打开文件表的文件偏移量，通过文件偏移量拿到i-node指针，最终找到真实的文件。</p><p><strong>小结：</strong></p><p>当用户打开一个文件，用户只得到了一个 <code>fd</code> 句柄，但内核做了很多事情，梳理下来，我们得到几个关键的数据结构，这几个数据结构是有层次递进关系的，我们简单梳理下：</p><ol><li>进程结构 <code>task_struct</code> ：表征进程实体，每一个进程都和一个 <code>task_struct</code> 结构体对应，其中 <code>task_struct.files</code> 指向一个管理打开文件的结构体 <code>fiels_struct</code> ；</li><li>文件表项管理结构 <code>files_struct</code> ：用于管理进程打开的 open 文件列表，内部以数组的方式实现（静态数组和动态数组结合）。返回给用户的 <code>fd</code> 就是这个数组的<strong>编号索引</strong>而已，索引元素为 <code>file</code> 结构；</li></ol><ul><li><strong><code>files_struct</code> 只从属于某进程；</strong></li></ul><p>​文件 <code>file</code> 结构：表征一个打开的文件，内部包含关键的字段有：<strong>当前文件偏移，inode 结构地址</strong>；</p><ul><li><strong>该结构虽然由进程触发创建，但是 <code>file</code> 结构可以在进程间共享；</strong></li></ul><p>​<code>vfs inode</code> 结构体：文件 <code>file</code> 结构指向 的是 vfs 的 <code>inode</code> ，这个是操作系统抽象出来的一层，用于屏蔽后端各种各样的文件系统的 <code>inode</code> 差异；</p><ul><li><strong>inode 这个具体进程无关，是文件系统级别的资源；</strong></li></ul><p>​<code>ext4 inode</code> 结构体（指代具体文件系统 inode ）：后端文件系统的 <code>inode</code> 结构，不同文件系统自定义的结构体，ext2 有 <code>ext2_inode_info</code>，ext4 有<code>ext4_inode_info</code>，minix 有 <code>minix_inode_info</code>，这些结构里都是内嵌了一个 vfs <code>inode</code> 结构体，原理相同；</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231010224514222.png" alt="image-20231010224514222"></p><p><strong>Liunx内核的VFS子系统</strong></p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231010225314350.png" alt="image-20231010225314350"></p><p>​文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。</p><p>​在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是<strong>对应不同的file结构体，因此可以有不同的File Status Flag和读写位置</strong>。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。</p><p>​每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。</p><p>​file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p><p>​每个file结构体都有一个指向dentry结构体的指针，<strong>“dentry”是directory entry（目录项）的缩写</strong>。我们传给open、stat等函数的参数的是一个路径，例如&#x2F;home&#x2F;akaedu&#x2F;a，需要根据路径找到文件的inode。<strong>为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache</strong>，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录&#x2F;找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p><p>​每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示&#x2F;home&#x2F;akaedu&#x2F;a和&#x2F;home&#x2F;akaedu&#x2F;b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。</p><p>​和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。</p><p>​inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到&#x2F;home目录下。</p><p>​file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p><h3 id="1-6-缓存IO"><a href="#1-6-缓存IO" class="headerlink" title="1.6 缓存IO"></a>1.6 缓存IO</h3><p>缓存IO又被称作标准IO，在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中（page cache）。即数据先被拷贝到内核的缓冲区中，随后才会被拷贝到应用程序的地址空间。</p><p>优点：可以解决CPU与IO速度冲突问题</p><p>缺点：数据传输过程中，数据在进程的<strong>地址空间与内核空间进行多次数据拷贝操作</strong>，CPU以及内存开销都很大。</p><p>总结：网络IO就是操作系统接收网卡收到的数据，缓存到一个buffer中，应用程序调用操作系统的函数（就是操作系统提供的IO接口），从对应的buffer中取出数据。操作系统在网络IO过程中充当了一个提供抽象接口的角色</p><h2 id="2-Liunx-IO模型"><a href="#2-Liunx-IO模型" class="headerlink" title="2.Liunx IO模型"></a>2.Liunx IO模型</h2><p>网络IO的本质是socket的读取，socket会被Linux抽象成流，IO可以看作是对流的操作。以Read举例子，对于一次IO访问，<strong>数据先被拷贝到内核的缓冲区中，然后才从操作系统内核的缓冲区中拷贝到应用程序的地址空间</strong>。</p><p>当发生一次Read操作时，会发生以下2个阶段：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">等待数据准备<br>将数据从内核拷贝到进程中<br></code></pre></td></tr></table></figure><p>对于Socket流而言，发生如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">通常等待网络上其他数据分组到达，然后被复制到内核的某个缓冲区中<br>把数据从内核的缓冲区复制到应用进程缓冲区<br></code></pre></td></tr></table></figure><p>网络IO有如下几种：</p><ul><li>同步模型（synchronous IO）</li><li>阻塞IO（blocking IO）</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li><li>异步IO（asynchronous IO）</li></ul><h3 id="2-1-同步阻塞IO"><a href="#2-1-同步阻塞IO" class="headerlink" title="2.1 同步阻塞IO"></a>2.1 同步阻塞IO</h3><p>用户空间的进程执行一个系统调用，比如recvfrom，这会导致应用程序阻塞，期间什么都不干，直到数据准备好，并且数据被从内核缓冲区复制到用户进程<br><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011093416174.png" alt="image-20231011093416174"></p><p>如上图所示，用户进程调用recvfrom这个系统调用，内核即开始IO的第一个阶段，对于网络IO来说，此时还未收到一个完整的数据包，通常需要等待其他数据报到来组成一个完整的数据包。这个过程是数据被复制到内核的某个缓冲区中。此时用户进程会自行阻塞。复制完后，进入第二个阶段。<strong>内核一直等到数据准备好了</strong>，就把数据从内核复制到用户空间。内核返回结果，用户进程解除阻塞状态，重新运行起来。</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011111441664.png" alt="image-20231011111441664"></p><h3 id="2-2-同步非阻塞IO"><a href="#2-2-同步非阻塞IO" class="headerlink" title="2.2 同步非阻塞IO"></a>2.2 同步非阻塞IO</h3><p>用户进程调用recvfrom系统调用，进程没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时返回一个error。进程收到返回后做些别的事请，过一会再发起recvfrom系统调用。如此循环重复，此过程常称为轮询。直到数据准备好并且已经被复制到用户空间。如下图所示：</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011095934835.png" alt="image-20231011095934835"></p><p>用户进程发出recvfrom操作，用户进程不会被阻塞，内核若还未准备好数据，则会返回一个error。<strong>此时用户进程可以干别的事请，过一会再调用recvfrom询问内核是否准备好了数据，此操作称为轮询</strong>。一旦内核准备好了数据并且用户进程前来询问，此时内核将数据复制到用户空间中并且返回。</p><h3 id="2-3-IO多路复用"><a href="#2-3-IO多路复用" class="headerlink" title="2.3 IO多路复用"></a>2.3 IO多路复用</h3><p>同步非阻塞IO是由用户进程去轮询内核是否准备好了数据。IO多路复用则使用<strong>一个特定的进程去轮询</strong>。这就是IO多路复用。常见的select、poll、epoll就是干这个的。select调用是内核级别的。select与同步非阻塞的区别在于：前者能等待多个socket，即能同时监听多个IO端口。当内核对任何一个socket准备好了部分数据（select无需等所有数据包到达内核后才开始，内核会负责监视是否有数据到达）就能返回，然后用户进程再进行recvfrom调用，将数据从内核复制到用户空间。</p><p>select、poll、epoll可以同时阻塞多个IO操作。直到内核监视到有数据到达内核，才真正调用IO操作函数。</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011103101687.png" alt="image-20231011103101687"></p><p>IO multiplexing就是常说的select、poll、epoll。好处是用一个进程即可处理多个网络连接的IO。其原理是select、poll、epoll不断地轮询负责的socket，当某个socket有数据到达内核，就通知用户进程。</p><p>用户进程调用select，整个进程会被阻塞。内核监视select负责的所有socket，任何一个有数据准备好，select就返回。此时用户再调用recvfrom，将数据从内核拷贝到用户进程。</p><h4 id="2-3-1-select原理"><a href="#2-3-1-select原理" class="headerlink" title="2.3.1 select原理"></a><strong>2.3.1 select原理</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds,                     <span class="hljs-comment">// 监控的文件描述符集里最大文件描述符加1</span></span><br><span class="hljs-params">    fd_set *readfds,              <span class="hljs-comment">// 监控有读数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *writefds,             <span class="hljs-comment">// 监控写数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *exceptfds,            <span class="hljs-comment">// 监控异常发生达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout)</span>;     <span class="hljs-comment">// 定时阻塞监控时间</span><br></code></pre></td></tr></table></figure><p>readfds、writefds、errorfds 是三个文件描述符集合。select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换这三个引用参数中的对应集合，返回所有就绪描述符的数量。</p><p>timeout 参数表示调用 select 时的阻塞时长。如果所有 fd 文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。</p><p><strong>fd_set 文件描述符集合</strong></p><p>select 函数参数中的 fd_set 类型表示文件描述符的集合。</p><p>由于文件描述符 fd 是一个从 0 开始的无符号整数，所以可以使用 fd_set 的二进制每一位来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 fd_set 长度为 1 字节，则一个 fd_set 变量最大可以表示 8 个文件描述符。当 select 返回 fd_set &#x3D; 00010011 时，表示文件描述符 1、2、5 已经就绪。</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011112434243.png" alt="image-20231011112434243"></p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011213646817.png" alt="image-20231011213646817"></p><h4 id="2-3-2-epoll实现原理"><a href="#2-3-2-epoll实现原理" class="headerlink" title="2.3.2 epoll实现原理"></a>2.3.2 epoll实现原理</h4><p>epoll 的特点是：</p><p>1）使用<strong>红黑树</strong>存储<strong>一份</strong>文件描述符集合，每个文件描述符只需在添加时传入一次，无需用户每次都重新传入；—— 解决了 select 中 fd_set 重复拷贝到内核的问题</p><p>2）通过异步 IO 事件找到就绪的文件描述符，而不是通过轮询的方式；</p><p>3）使用队列存储就绪的文件描述符，且会按需返回就绪的文件描述符，无须再次遍历；</p><p><strong>epoll_ctl</strong></p><p>epoll_ctl 函数主要负责把服务端和客户端建立的 socket 连接注册到 eventpoll 对象里，会做三件事：</p><p>1）创建一个 epitem 对象，主要包含两个字段，分别存放 socket fd 即连接的文件描述符，和所属的 eventpoll 对象的指针；</p><p>2）将一个数据到达时用到的回调函数添加到 socket 的进程等待队列中，注意，跟第 1.1 节的阻塞 IO 模式不同的是，这里添加的 socket 的进程等待队列结构中，只有回调函数，没有设置进程描述符，因为<strong>在 epoll 中，进程是放在 eventpoll 的等待队列中</strong>，等待被 epoll_wait 函数唤醒，而不是放在 socket 的进程等待队列中；</p><p>3）将第 1）步创建的 epitem 对象插入红黑树；</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011215103788.png" alt="image-20231011215103788"></p><p><strong>epoll_wait</strong></p><p>epoll_wait 函数的动作比较简单，检查 eventpoll 对象的就绪的连接 rdllist 上是否有数据到达，如果没有就把当前的进程描述符添加到一个等待队列项里，加入到 eventpoll 的进程等待队列里，然后阻塞当前进程，等待数据到达时通过回调函数被唤醒。</p><p>当 eventpoll 监控的连接上有数据到达时，通过下面几个步骤唤醒对应的进程处理数据：</p><p>1）socket 的数据接收队列有数据到达，会通过进程等待队列的回调函数 ep_poll_callback 唤醒红黑树中的节点 epitem；</p><p>2）ep_poll_callback 函数将有数据到达的 epitem 添加到 eventpoll 对象的就绪队列 rdllist 中；</p><p>3）ep_poll_callback 函数检查 eventpoll 对象的进程等待队列上是否有等待项，通过回调函数 default_wake_func 唤醒这个进程，进行数据的处理；</p><p>4）当进程醒来后，继续从 epoll_wait 时暂停的代码继续执行，把 rdlist 中就绪的事件返回给用户进程，让用户进程调用 recv 把已经到达内核 socket 等待队列的数据拷贝到用户空间使用。</p><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231011220001774.png" alt="image-20231011220001774"></p><h4 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3 总结"></a>2.3.3 总结</h4><p>从阻塞 IO 到 epoll 的实现中，我们可以看到 <strong>wake up 回调函数机制</strong>被频繁的使用，至少有三处地方：一是阻塞 IO 中数据到达 socket 的等待队列时，通过回调函数唤醒进程，二是 epoll 中数据到达 socket 的等待队列时，通过回调函数 ep_poll_callback 找到 eventpoll 中红黑树的 epitem 节点，并将其加入就绪列队 rdllist，三是通过回调函数 default_wake_func 唤醒用户进程 ，并将 rdllist 传递给用户进程，让用户进程准确读取数据 。从中可知，这种回调机制能够定向准确的通知程序要处理的事件，而不需要每次都循环遍历检查数据是否到达以及数据该由哪个进程处理，提高了程序效率，在日常的业务开发中，我们也可以借鉴下这一机制。</p><h3 id="2-4-信号驱动式IO"><a href="#2-4-信号驱动式IO" class="headerlink" title="2.4 信号驱动式IO"></a>2.4 信号驱动式IO</h3><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231012105822167.png" alt="image-20231012105822167"></p><h3 id="2-5-异步IO"><a href="#2-5-异步IO" class="headerlink" title="2.5 异步IO"></a>2.5 异步IO</h3><p><img src="C:\Users\tony\AppData\Roaming\Typora\typora-user-images\image-20231012105909004.png" alt="image-20231012105909004"></p><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p><strong>同步：</strong>发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 例如：B&#x2F;S模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。</p><p><strong>异步：</strong>异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>对于通知调用者的三种方式，具体如下：</p><ul><li>状态</li></ul><p>即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p><ul><li>通知</li></ul><p>当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p><ul><li>回调</li></ul><p>与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p><p>例如：B&#x2F;S模式中的ajax请求，具体过程是：客户端发出ajax请求-&gt;服务端处理-&gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。</p><p><strong>总结来说，同步和异步的区别：请求发出后，是否需要等待结果，才能继续执行其他操作。</strong></p><p><strong>阻塞：</strong>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p><strong>非阻塞：</strong>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>总体来说：阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</strong></p><p><strong>同步阻塞</strong>：小明一直盯着下载进度条，到 100% 的时候就完成。 - 同步体现在：等待下载完成通知。 - 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理。</p><p><strong>同步非阻塞</strong>：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。 - 同步体现在：等待下载完成通知。 - 非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条。【小明必须要在两个任务间切换，关注下载进度】</p><p><strong>异步阻塞</strong>：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明不做别的事，仍然一直等待“叮”的声音。 - 异步体现在：下载完成“叮”一声通知。 - 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理。</p><p><strong>异步非阻塞</strong>：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 - 异步体现在：下载完成“叮”一声通知。 - 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-liunx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>liunx命令</title>
    <link href="/2023/10/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/10/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="liunx命令"><a href="#liunx命令" class="headerlink" title="liunx命令"></a>liunx命令</h1><h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1.文件结构"></a>1.文件结构</h2><table><thead><tr><th>文件</th><th align="left">描述</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td align="left">二进制文件</td></tr><tr><td>&#x2F;boot</td><td align="left">系统启动分区</td></tr><tr><td>&#x2F;dev</td><td align="left">设备文件</td></tr><tr><td>&#x2F;etc</td><td align="left">大多数配置文件</td></tr><tr><td>&#x2F;home</td><td align="left">普通用户的家目录</td></tr><tr><td>&#x2F;lib</td><td align="left">32位函数库</td></tr><tr><td>&#x2F;lib64</td><td align="left">64位库</td></tr><tr><td>&#x2F;media</td><td align="left">手动临时挂载点</td></tr><tr><td>&#x2F;mnt</td><td align="left">手动临时挂载点</td></tr><tr><td>&#x2F;opt</td><td align="left">第三方软件安装位置</td></tr><tr><td>&#x2F;proc</td><td align="left">进程信息及硬件信息</td></tr><tr><td>&#x2F;sbin</td><td align="left">系统管理命令</td></tr><tr><td>&#x2F;srv</td><td align="left">数据</td></tr><tr><td>&#x2F;var</td><td align="left">数据</td></tr><tr><td>&#x2F;sys</td><td align="left">内核相关信息</td></tr><tr><td>&#x2F;tmp</td><td align="left">临时文件</td></tr><tr><td>&#x2F;usr</td><td align="left">用户相关设定</td></tr></tbody></table><h2 id="2-命令行含义"><a href="#2-命令行含义" class="headerlink" title="2.命令行含义"></a>2.命令行含义</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">示例：root@app00:~# <br>root    //用户名，root为超级用户<br>@       //分隔符<br>app00   //主机名称<br>~       //当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下）<br><span class="hljs-meta prompt_"># </span><span class="language-bash">     //表示当前用户是超级用户，普通用户为$，例如：（<span class="hljs-string">&quot;yao@app00:/root$&quot;</span> ，表示使用用户<span class="hljs-string">&quot;yao&quot;</span>访问/root文件夹）</span><br></code></pre></td></tr></table></figure><h2 id="3-目录操作"><a href="#3-目录操作" class="headerlink" title="3.目录操作"></a>3.目录操作</h2><h3 id="3-1-切换目录（cd）"><a href="#3-1-切换目录（cd）" class="headerlink" title="3.1 切换目录（cd）"></a>3.1 切换目录（cd）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /                 //切换到根目录<br>cd /bin              //切换到根目录下的bin目录<br>cd ../               //切换到上一级目录 或者使用命令：cd ..<br>cd ~                 //切换到home目录<br>cd -                 //切换到上次访问的目录<br>cd xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错<br>cd /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全<br></code></pre></td></tr></table></figure><h3 id="3-2-查看目录（ls）"><a href="#3-2-查看目录（ls）" class="headerlink" title="3.2 查看目录（ls）"></a>3.2 查看目录（ls）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls                   //查看当前目录下的所有目录和文件<br>ls -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令&quot;ll&quot;效果一样<br>ls /bin              //查看指定目录下的所有目录和文件 <br></code></pre></td></tr></table></figure><h3 id="3-3-创建目录（mkdir）"><a href="#3-3-创建目录（mkdir）" class="headerlink" title="3.3 创建目录（mkdir）"></a>3.3 创建目录（mkdir）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir tools          //在当前目录下创建一个名为tools的目录<br>mkdir /bin/tools     //在指定目录下创建一个名为tools的目录<br></code></pre></td></tr></table></figure><h3 id="3-4-修改目录（mv"><a href="#3-4-修改目录（mv" class="headerlink" title="3.4  修改目录（mv)"></a>3.4  修改目录（mv)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 当前目录名 新目录名        //修改目录名，同样适用与文件操作<br>mv /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面<br>mv -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹<br></code></pre></td></tr></table></figure><h3 id="3-5-删除目录与文件（rm）"><a href="#3-5-删除目录与文件（rm）" class="headerlink" title="3.5 删除目录与文件（rm）"></a>3.5 删除目录与文件（rm）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名              //删除当前目录下的文件<br>rm -f 文件名           //删除当前目录的的文件（不询问）<br>rm -r 文件夹名         //递归删除当前目录下此名的目录<br>rm -rf 文件夹名        //递归删除当前目录下此名的目录（不询问）<br>rm -rf *              //将当前目录下的所有目录和文件全部删除<br>rm -rf /*             //将根目录下的所有文件全部删除【慎用！相当于格式化系统】<br></code></pre></td></tr></table></figure><h3 id="3-6-拷贝目录（cp）"><a href="#3-6-拷贝目录（cp）" class="headerlink" title="3.6 拷贝目录（cp）"></a>3.6 拷贝目录（cp）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面<br>cp -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹<br></code></pre></td></tr></table></figure><h3 id="3-7-搜索目录（find）"><a href="#3-7-搜索目录（find）" class="headerlink" title="3.7 搜索目录（find）"></a>3.7 搜索目录（find）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /bin -name &#x27;a*&#x27;        //查找/bin目录下的所有以a开头的文件或者目录<br></code></pre></td></tr></table></figure><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h2><h3 id="4-1-新增文件（touch）"><a href="#4-1-新增文件（touch）" class="headerlink" title="4.1 新增文件（touch）"></a>4.1 新增文件（touch）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch  a.txt         //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间<br>vim a.txt<br>cat &lt; daygeek4.txt<br></code></pre></td></tr></table></figure><h3 id="4-2-删除文件（rm）"><a href="#4-2-删除文件（rm）" class="headerlink" title="4.2 删除文件（rm）"></a>4.2 删除文件（rm）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名              //删除当前目录下的文件<br>rm -f 文件名           //删除当前目录的的文件（不询问）<br></code></pre></td></tr></table></figure><h3 id="4-3-编辑文件（vi、vim）"><a href="#4-3-编辑文件（vi、vim）" class="headerlink" title="4.3 编辑文件（vi、vim）"></a>4.3 编辑文件（vi、vim）</h3><h3 id="4-4-查看文件-tail、cat、less、more"><a href="#4-4-查看文件-tail、cat、less、more" class="headerlink" title="4.4 查看文件(tail、cat、less、more)"></a>4.4 查看文件(tail、cat、less、more)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.txt          //查看文件最后一屏内容<br>less a.txt         //PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看<br>more a.txt         //显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看<br>tail -100 a.txt    //查看文件的后100行，&quot;Ctrl+C&quot;退出查看<br></code></pre></td></tr></table></figure><h2 id="5-文件权限"><a href="#5-文件权限" class="headerlink" title="5.文件权限"></a>5.文件权限</h2><h3 id="5-1-权限说明"><a href="#5-1-权限说明" class="headerlink" title="5.1 权限说明"></a>5.1 权限说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">文件权限简介：&#x27;r&#x27; 代表可读（4），&#x27;w&#x27; 代表可写（2），&#x27;x&#x27; 代表执行权限（1），括号内代表&quot;8421法&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#文件权限信息示例：-rwxrw-r--</span></span><br>-第一位：&#x27;-&#x27;就代表是文件，&#x27;d&#x27;代表是文件夹<br>-第一组三位：拥有者的权限<br>-第二组三位：拥有者所在的组，组员的权限<br>-第三组三位：代表的是其他用户的权限<br></code></pre></td></tr></table></figure><h3 id="5-2-文件权限"><a href="#5-2-文件权限" class="headerlink" title="5.2 文件权限"></a>5.2 文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">普通授权    chmod +x a.txt    <br>8421法     chmod 777 a.txt     //1+2+4=7，&quot;7&quot;说明授予所有权限<br></code></pre></td></tr></table></figure><h2 id="6-打包与解压（tar）"><a href="#6-打包与解压（tar）" class="headerlink" title="6.打包与解压（tar）"></a>6.打包与解压（tar）</h2><h3 id="6-1-说明"><a href="#6-1-说明" class="headerlink" title="6.1 说明"></a>6.1 说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.zip、.rar        //windows系统中压缩文件的扩展名<br>.tar              //Linux中打包文件的扩展名<br>.gz               //Linux中压缩文件的扩展名<br>.tar.gz           //Linux中打包并压缩文件的扩展名<br></code></pre></td></tr></table></figure><h3 id="6-2-打包文件"><a href="#6-2-打包文件" class="headerlink" title="6.2 打包文件"></a>6.2 打包文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf 打包压缩后的文件名 要打包的文件<br>参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;<br>示例：<br>tar -zcvf a.tar file1 file2,...      //多个文件压缩打包<br></code></pre></td></tr></table></figure><h3 id="6-3-解压文件"><a href="#6-3-解压文件" class="headerlink" title="6.3 解压文件"></a>6.3 解压文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf a.tar                      //解包至当前目录<br>tar -zxvf a.tar -C /usr------        //指定解压的位置<br>unzip test.zip             //解压*.zip文件 <br>unzip -l test.zip          //查看*.zip文件的内容 <br></code></pre></td></tr></table></figure><h2 id="7-其他常用命令"><a href="#7-其他常用命令" class="headerlink" title="7. 其他常用命令"></a>7. 其他常用命令</h2><h3 id="7-1-find"><a href="#7-1-find" class="headerlink" title="7.1 find"></a>7.1 find</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*.c&quot;     //将目前目录及其子目录下所有延伸档名是 c 的文件列出来<br>find . -type f         //将目前目录其其下子目录中所有一般文件列出<br>find . -ctime -20      //将目前目录及其子目录下所有最近 20 天内更新过的文件列出<br>find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;     //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们<br>find . -type f -perm 644 -exec ls -l &#123;&#125; \;       //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br>find / -type f -size 0 -exec ls -l &#123;&#125; \;         //为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br></code></pre></td></tr></table></figure><h3 id="7-2-whereis"><a href="#7-2-whereis" class="headerlink" title="7.2 whereis"></a>7.2 whereis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whereis ls             //将和ls文件相关的文件都查找出来<br></code></pre></td></tr></table></figure><h3 id="7-3-grep"><a href="#7-3-grep" class="headerlink" title="7.3 grep"></a>7.3 grep</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -i &quot;the&quot; demo_file              //在文件中查找字符串(不区分大小写)<br>grep -A 3 -i &quot;example&quot; demo_text     //输出成功匹配的行，以及该行之后的三行<br>grep -r &quot;ramesh&quot; *                   //在一个文件夹中递归查询包含指定字符串的文件<br></code></pre></td></tr></table></figure><h3 id="7-4-free"><a href="#7-4-free" class="headerlink" title="7.4 free"></a>7.4 free</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">说明：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况 <br>free -g            //以G为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节 <br>free -t            //查看所有内存的汇总<br></code></pre></td></tr></table></figure><h3 id="7-5-top"><a href="#7-5-top" class="headerlink" title="7.5 top"></a>7.5 top</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top               //显示当前系统中占用资源最多的一些进程, shift+m 按照内存大小查看<br></code></pre></td></tr></table></figure><h3 id="7-6-df"><a href="#7-6-df" class="headerlink" title="7.6 df"></a>7.6 df</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">说明：显示文件系统的磁盘使用情况<br>df -h            //一种易看的显示<br></code></pre></td></tr></table></figure><h3 id="7-7-ssh"><a href="#7-7-ssh" class="headerlink" title="7.7 ssh"></a>7.7 ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@remote -p port<br>//user 是你在远程机器上的用户名，如果不指定的话默认为当前用户<br>//remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名<br>//port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22<br></code></pre></td></tr></table></figure><h3 id="7-8-scp"><a href="#7-8-scp" class="headerlink" title="7.8 scp"></a>7.8 scp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /opt/data.txt  192.168.1.101:/opt/    //将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下<br></code></pre></td></tr></table></figure><h3 id="7-9-查看进程"><a href="#7-9-查看进程" class="headerlink" title="7.9 查看进程"></a>7.9 查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef         //查看所有正在运行的进程<br></code></pre></td></tr></table></figure><h3 id="7-10-结束进程"><a href="#7-10-结束进程" class="headerlink" title="7.10 结束进程"></a>7.10 结束进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill pid       //杀死该pid的进程<br>kill -9 pid    //强制杀死该进程   <br></code></pre></td></tr></table></figure><h3 id="7-11-查看链接"><a href="#7-11-查看链接" class="headerlink" title="7.11 查看链接"></a>7.11 查看链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping IP        //查看与此IP地址的连接情况<br>netstat -an    //查看当前系统端口<br>netstat -an | grep 8080     //查看指定端口<br></code></pre></td></tr></table></figure><h3 id="7-12-查看网络"><a href="#7-12-查看网络" class="headerlink" title="7.12 查看网络"></a>7.12 查看网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h2 id="8-实用命令"><a href="#8-实用命令" class="headerlink" title="8.实用命令"></a>8.实用命令</h2><p>看8080端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nap|grep :8080   <br>//结果分别为：<br>协议名-网络接受队列-网络发送队列-本地地址-外部地址-链路状态-进程ip/应用程序<br></code></pre></td></tr></table></figure><p>强制杀死所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 `ps -aux|awk &#x27;&#123;print $2&#125;&#x27;`<br></code></pre></td></tr></table></figure><p>忽略大小写匹配a的行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -o -i &#x27;a&#x27; aaa.txt|wc -l<br></code></pre></td></tr></table></figure><p>查找最后500行日志的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Tail -n 500 文件名<br></code></pre></td></tr></table></figure><p>grep擅长查找，sed擅长修改文件、awk擅长取列</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-liunx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/08/hello-world/"/>
    <url>/2023/10/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
