<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库3</title>
    <link href="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/"/>
    <url>/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库3"><a href="#数据库3" class="headerlink" title="数据库3"></a>数据库3</h1><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><h3 id="1-1-为什么要加锁"><a href="#1-1-为什么要加锁" class="headerlink" title="1.1 为什么要加锁"></a>1.1 为什么要加锁</h3><p>当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><h3 id="1-2-锁的分类"><a href="#1-2-锁的分类" class="headerlink" title="1.2 锁的分类"></a>1.2 锁的分类</h3><img src="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022213448654.png" class title="image-20231022213448654"><h4 id="1-2-1-乐观锁"><a href="#1-2-1-乐观锁" class="headerlink" title="1.2.1 乐观锁"></a>1.2.1 乐观锁</h4><p>乐观锁并不是一个真的锁，而是一种思想，CAS（compare and swap）技术，CAS流程如下</p><img src="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022211807774.png" class title="image-20231022211807774"><p>乐观锁不需要加锁就可以实现锁的功能，但是乐观锁有一个很严重的问题就是ABA问题</p><p><strong>本质：</strong>在于CAS在修改变量的时候，无法记录变量的状态，比如修改的次数，是否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成CAS多次执行的问题</p><p><strong>解决方案：</strong>添加版本号，这时不仅要比较数值还需要比较版本号，除此之外，我们也可以用时间戳来进行比较，看看数据是否是新数据</p><p><strong>CAS优点：</strong>并发情况好，不用上锁</p><p><strong>CAS缺点：</strong>循环时间长开销大、只能保证一个共享变量的原子操作</p><h4 id="1-2-2-悲观锁"><a href="#1-2-2-悲观锁" class="headerlink" title="1.2.2 悲观锁"></a>1.2.2 悲观锁</h4><p><strong>1.全局锁：</strong>对整个数据库实例加锁，用于全库逻辑备份</p><p><strong>2.表级锁：</strong>当前操作的整张表加锁，最常使用的 MyISAM 与 InnoDB 都支持表级锁定</p><p><strong>3.页级锁：</strong>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 引擎支持页级锁。</p><p><strong>4.行级锁：</strong>行级锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。MySQL中只有InnoDB支持行级锁，行级锁分为共享锁和排他锁。</p><h4 id="1-2-3-共享锁与排他锁"><a href="#1-2-3-共享锁与排他锁" class="headerlink" title="1.2.3 共享锁与排他锁"></a>1.2.3 共享锁与排他锁</h4><p><strong>共享锁：</strong>又称之为读锁，简称S锁，当事务A对数据加上读锁后，其他事务只能对该数据加读锁，不能做任何修改操作，也就是不能添加写锁。只有当事务A上的读锁被释放后，其他事务才能对其添加写锁。</p><p><strong>排他锁：</strong>排它锁，又称之为写锁，简称X锁，当事务对数据加上写锁后，其他事务既不能对该数据添加读写，也不能对该数据添加写锁，写锁与其他锁都是互斥的。只有当前数据写锁被释放后，其他事务才能对其添加写锁或者是读锁。</p><p>MySQL InnoDB引擎默认update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p><h4 id="1-2-4-意向共享锁与意向排他锁"><a href="#1-2-4-意向共享锁与意向排他锁" class="headerlink" title="1.2.4 意向共享锁与意向排他锁"></a>1.2.4 意向共享锁与意向排他锁</h4><p>意向锁是表锁，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><p><strong>作用：</strong>当有事务A有行锁时，MySQL会自动为该表添加意向锁，事务B如果想申请整个表的写锁，那么不需要遍历每一行判断是否存在行锁，而直接判断是否存在意向锁，增强性能。</p><h4 id="1-2-5-间隙锁、临键锁、记录锁"><a href="#1-2-5-间隙锁、临键锁、记录锁" class="headerlink" title="1.2.5 间隙锁、临键锁、记录锁"></a>1.2.5 间隙锁、临键锁、记录锁</h4><p><strong>记录锁：</strong>记录锁是封锁记录，记录锁也叫行锁</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select from goods where id=1 for update;<br></code></pre></td></tr></table></figure><p>它会在 id&#x3D;1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id&#x3D;1 这一行。</p><p><strong>间隙锁：</strong>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select from goods where id between 1 and 10 for update;<br></code></pre></td></tr></table></figure><p>即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1和 10 两条记录行并不会被锁住</p><p><strong>临键锁：</strong>是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间，是一个左开右闭区间。临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。</p><p>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><img src="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022214453190.png" class title="image-20231022214453190"><p>goods表中隐藏的临键锁有：(-∞, 96],(96, 99],(99, +∞]</p><p>session1 在对 number 为 96 的列进行 update 操作的同时，也获取了(-∞, 96],(96, 99]这两个区间内的临键锁。</p><h2 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h2><h3 id="2-1-死锁原因"><a href="#2-1-死锁原因" class="headerlink" title="2.1 死锁原因"></a>2.1 死锁原因</h3><ol><li><strong>互斥条件</strong>：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。</li><li><strong>请求和保持条件</strong>：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。</li><li><strong>不可剥夺条件</strong>：指运算单元已获得的资源，在未使用完之前，不能被剥夺。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。</li></ol><img src="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022214754272.png" class title="image-20231022214754272"><h3 id="2-2-死锁解决方案"><a href="#2-2-死锁解决方案" class="headerlink" title="2.2 死锁解决方案"></a>2.2 死锁解决方案</h3><p>接下来我们来分析一下，产生死锁的 4 个条件，哪些是可以破坏的？哪些是不能被破坏的？</p><ul><li>互斥条件：系统特性，不能被破坏。</li><li><strong>请求和保持条件：可以被破坏。</strong></li><li>不可剥夺条件：系统特性，不能被破坏。</li><li><strong>循环等待条件：可以被破坏。</strong></li></ul><p>通过上述分析，我们可以得出结论，我们只能通过破坏请求和保持条件或者是环路等待条件，从而来解决死锁的问题，那上线，我们就先从破坏“环路等待条件”开始来解决死锁问题。</p><h4 id="2-2-1-解决方案1：顺序锁"><a href="#2-2-1-解决方案1：顺序锁" class="headerlink" title="2.2.1  解决方案1：顺序锁"></a>2.2.1  解决方案1：顺序锁</h4><img src="/2023/10/22/%E6%95%B0%E6%8D%AE%E5%BA%933/image-20231022215036126.png" class title="image-20231022215036126"><p>之前循环等待，但是我们现在规定资源获取顺序是固定的，也就是先A再B，这时候如果线程2没有获取资源A那么也不会去争夺资源B</p><h4 id="2-2-2-解决方案2：轮询锁"><a href="#2-2-2-解决方案2：轮询锁" class="headerlink" title="2.2.2 解决方案2：轮询锁"></a>2.2.2 解决方案2：轮询锁</h4><p>轮询锁是通过打破“请求和保持条件”来避免造成死锁的，它的实现思路简单来说就是通过轮询来尝试获取锁，如果有一个锁获取失败，则释放当前线程拥有的所有锁，等待下一轮再尝试获取锁。</p><h4 id="2-2-3-避免死锁"><a href="#2-2-3-避免死锁" class="headerlink" title="2.2.3 避免死锁"></a>2.2.3 避免死锁</h4><p><strong>银行家算法：</strong>预先分配看看是否会发送死锁，如果存在发送死锁可能性就不分配</p><h2 id="3-发生死锁如何排查"><a href="#3-发生死锁如何排查" class="headerlink" title="3.发生死锁如何排查"></a>3.发生死锁如何排查</h2><p>1.查看正在进行中的事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.INNODB_TRX<br></code></pre></td></tr></table></figure><p>2.查看正在锁的事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;<br></code></pre></td></tr></table></figure><p>3.查看等待锁的事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;<br></code></pre></td></tr></table></figure><p>4.查询是否锁表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW OPEN TABLES where In_use &gt; 0;<br></code></pre></td></tr></table></figure><p>5.查看最近死锁的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engine innodb status<br></code></pre></td></tr></table></figure><p><strong>关键字：EXPLAIN</strong>可以看表的读取顺序、数据读取操作的类型、哪些索引可以使用、哪些索引实际使用、表之间的引用、每张表有多少行被优化器查询</p><h2 id="4-备注"><a href="#4-备注" class="headerlink" title="4.备注"></a>4.备注</h2><p>部分材料来源于：</p><p><a href="https://juejin.cn/post/6931752749545553933">史上最全MySQL各种锁详解 - 掘金 (juejin.cn)</a></p><p><a href="https://cloud.tencent.com/developer/article/1875648">1.3w字，一文详解死锁！-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库2</title>
    <link href="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/"/>
    <url>/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库2"><a href="#数据库2" class="headerlink" title="数据库2"></a>数据库2</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><h3 id="1-1-事务的状态"><a href="#1-1-事务的状态" class="headerlink" title="1.1 事务的状态"></a>1.1 事务的状态</h3><p>事务的状态有三种：Active、Commited、Failed</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014172910037.png" class title="image-20231014172910037"><p>但是其实还有很多中间状态，比如部分提交，事务的状态图也会越来越复杂</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014172950181.png" class title="image-20231014172950181"><ul><li>Active：事务的初始状态，表示事务正在执行；</li><li>Partially Commited：在最后一条语句执行之后；</li><li>Failed：发现事务无法正常执行之后；</li><li>Aborted：事务被回滚并且数据库恢复到了事务进行之前的状态之后；</li><li>Commited：成功执行整个事务；</li></ul><h3 id="1-2事务的四大特性（ACID"><a href="#1-2事务的四大特性（ACID" class="headerlink" title="1.2事务的四大特性（ACID)"></a>1.2事务的四大特性（ACID)</h3><h4 id="1-2-1-原子性"><a href="#1-2-1-原子性" class="headerlink" title="1.2.1 原子性"></a>1.2.1 原子性</h4><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。</p><p><strong>原子性实现：</strong>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，而在 MySQL 中，恢复机制是通过<em>回滚日志</em>（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014173352748.png" class title="image-20231014173352748"><p>回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志<strong>逻辑地</strong>将数据库中的修改撤销掉看，可以<strong>理解</strong>为，我们在事务中使用的每一条 <code>INSERT</code> 都对应了一条 <code>DELETE</code>，每一条 <code>UPDATE</code> 也都对应一条相反的 <code>UPDATE</code> 语句。</p><p><strong>级联回滚：</strong>在下图所示的一次事件中，Transaction2 依赖于 Transaction1，而 Transaction3 又依赖于 Transaction1，当 Transaction1 由于执行出现问题发生回滚时，为了保证事务的原子性，就会将 Transaction2 和 Transaction3 中的工作全部回滚，这种情况也叫做<em>级联回滚</em>（Cascading Rollback），级联回滚的发生会导致大量的工作需要撤回，是我们难以接受的，不过如果想要达到<strong>绝对的</strong>原子性，这件事情又是不得不去处理的。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014173217570.png" class title="image-20231014173217570"><h4 id="1-2-2-持久性"><a href="#1-2-2-持久性" class="headerlink" title="1.2.2 持久性"></a>1.2.2 持久性</h4><p>既然是数据库，那么一定对数据的持久存储有着非常强烈的需求，如果数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上；而事务的持久性就体现在，一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。</p><p><strong>持久性实现：</strong>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014173510293.png" class title="image-20231014173510293"><p>当我们在一个事务中尝试对数据进行修改时，它<strong>会先将数据从磁盘读入内存，并更新内存中缓存的数据（数据一致性）</strong>，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将<strong>重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上</strong>，图中的第 4、5 步就是在事务提交时执行的。</p><h4 id="1-2-3-隔离性"><a href="#1-2-3-隔离性" class="headerlink" title="1.2.3 隔离性"></a>1.2.3 隔离性</h4><p><strong>隔离级别：</strong></p><ul><li><code>RAED UNCOMMITED</code>（读未提交）：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read（脏读））；</li><li><code>READ COMMITED</code>（读提交）：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read（不可重复读））；</li><li><code>REPEATABLE READ</code>（可重复读）：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li><li><code>SERIALIZABLE</code>（串行化）：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li></ul><p><strong>隔离级别的实现：</strong>锁（共享锁和互斥锁）、时间戳（乐观锁，先对数据进行修改，写回时再去判断当前值，如果时间戳（或者版本）没有改变就写入，否则，再生成一个新的时间戳再更新数据）、多版本和快照隔离，具体内容后面会详细解释</p><h4 id="1-2-4-一致性"><a href="#1-2-4-一致性" class="headerlink" title="1.2.4 一致性"></a>1.2.4 一致性</h4><p>数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</p><p>我们可以将事务理解成一个函数，它接受一个外界的 SQL 输入和一个一致的数据库，它一定会返回一个一致的数据库。</p><p>而第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</p><p>CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；而 ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的</p><h2 id="2-事务四种隔离详解"><a href="#2-事务四种隔离详解" class="headerlink" title="2.事务四种隔离详解"></a>2.事务四种隔离详解</h2><p>首先，事务四种隔离级别为：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ol><h3 id="2-1-读未提交"><a href="#2-1-读未提交" class="headerlink" title="2.1 读未提交"></a>2.1 读未提交</h3><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014174818199.png" class title="image-20231014174818199"><p>读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据。这时候就会出现错误。</p><p><strong>后果：</strong>导致读到其他脏数据</p><p><strong>原因：</strong>因为记录并没有加锁，所有人都可以访问到</p><p><strong>解决方案：</strong>对记录加记录锁，这时隔离级别就变成读提交了</p><h3 id="2-2-读提交"><a href="#2-2-读提交" class="headerlink" title="2.2 读提交"></a>2.2 读提交</h3><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014175222304.png" class title="image-20231014175222304"><p><strong>后果：</strong>后面读的数据和之前读的不一样，一般情况下不会出现问题，但是如果在数据库备份时，数据还有可能在不断修改，我们肯定希望备份整个数据库开始时的那个版本，而不希望备份的数据有些是之前那个时刻版本的，有些则是之后那个时间版本的。这样导致新来的数据覆盖掉了旧的数据，那么旧的数据就无法再找到了。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180524398.png" class title="image-20231014180524398"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180620939.png" class title="image-20231014180620939"><p><strong>原因：</strong>因为对记录加了锁，所以这时候只能读到新数据</p><p><strong>解决方案：</strong>MVCC（多版本和快照隔离），这时隔离级别变成了可重复读</p><h3 id="2-3-可重复读"><a href="#2-3-可重复读" class="headerlink" title="2.3 可重复读"></a>2.3 可重复读</h3><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180804387.png" class title="image-20231014180804387"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014180812441.png" class title="image-20231014180812441"><p><strong>后果：</strong>两次查询结果不一样</p><p><strong>原因：</strong>因为MVCC（多版本和快照隔离），其实有两种，第一种select是快照读，会保留之前的数据，但是update会给这个记录加锁，这样锁+select就变成了当前读，导致读出来的数据不一样了，通过next-key锁（间隙锁+记录锁)只锁住一部分区间使得有部分区间不会发送幻读</p><p><strong>解决方案：</strong>加表锁，隔离级别变成串行化</p><h3 id="2-4-串行化"><a href="#2-4-串行化" class="headerlink" title="2.4 串行化"></a>2.4 串行化</h3><p>加表锁，运行效率很低，但是隔离级别最高</p><h3 id="2-5-MVCC机制"><a href="#2-5-MVCC机制" class="headerlink" title="2.5 MVCC机制"></a>2.5 MVCC机制</h3><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231014203705388.png" class title="image-20231014203705388"><p>MVCC由Undo Log和Read View共同实现，Undo Log形成版本链，通过roll_potinter连接起来，并且记录对应的事务结果。</p><p>Read View是select在查询时做的一个内存视图</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015231621744.png" class title="image-20231015231621744"><p>RC不可以解决可重复读，两次ReadView都不同</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015231807060.png" class title="image-20231015231807060"><p>RR隔离级别，复用之前ReadView</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015232006679.png" class title="image-20231015232006679"><p>因为有临键锁，所有加锁的SELECT会变成当前读，导致出现幻读情况</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015232153209.png" class title="image-20231015232153209"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015232356249.png" class title="image-20231015232356249"><p>当SELECT没有被临键锁的范围覆盖时，还是会复用之前的ReadView，这时就没有发送幻读</p><h2 id="3-数据库日志"><a href="#3-数据库日志" class="headerlink" title="3.数据库日志"></a>3.数据库日志</h2><h3 id="3-1-重做日志（redo-log）"><a href="#3-1-重做日志（redo-log）" class="headerlink" title="3.1 重做日志（redo log）"></a>3.1 重做日志（redo log）</h3><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231022220311901.png" class title="image-20231022220311901"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231022220340221.png" class title="image-20231022220340221"><p>重做日志（redo log）是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。</p><p>InnoDB引擎对数据的更新，是<strong>先将更新记录写入redo log日志</strong>，然后会在系统<strong>空闲</strong>的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的<strong>预写式技术（Write Ahead logging）</strong>。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233136249.png" class title="image-20231015233136249"><p>redo log日志的大小是固定的，为了能够持续不断的对更新记录进行写入，在redo log日志中设置了两个标志位置，checkpoint和write_pos，分别表示记录擦除的位置和记录写入的位置。</p><p>当<code>write_pos</code>追上<code>checkpoint</code>时，表示redo log日志已经写满。这时不能继续执行新的数据库更新语句，需要停下来先删除一些记录，执行<strong>checkpoint规则</strong>腾出可写空间。</p><blockquote><p><strong>checkpoint规则：</strong>checkpoint触发后，将buffer中脏数据页和脏日志页都刷到磁盘。<br><strong>脏数据</strong>：指内存中未刷到磁盘的数据。</p></blockquote><p>redo log中最重要的概念就是缓冲池<code>buffer pool</code>，这是在内存中分配的一个区域，包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。</p><blockquote><p>当请求读取数据时，会先判断是否在缓冲池命中，如果未命中才会在磁盘上进行检索后放入缓冲池；<br>当请求写入数据时，会先写入缓冲池，缓冲池中修改的数据会定期刷新到磁盘中。这一过程也被称之为<strong>刷脏</strong> </p></blockquote><p>当数据修改时，除了修改<code>buffer pool</code>中的数据，还会在redo log中记录这次操作；当事务提交时，会根据redo log的记录对数据进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，从而保证了事务的持久性，使得数据库获得<code>crash-safe</code>能力。</p><h4 id="脏日志刷盘"><a href="#脏日志刷盘" class="headerlink" title="脏日志刷盘"></a>脏日志刷盘</h4><p>除了上面提到的对于脏数据的刷盘，实际上redo log日志在记录时，为了保证日志文件的持久化，也需要经历将日志记录从内存写入到磁盘的过程。redo log日志可分为两个部分，一是存在易失性内存中的缓存日志<code>redo log buff</code>，二是保存在磁盘上的redo log日志文件<code>redo log file</code>。<br>为了确保每次记录都能够写入到磁盘中的日志中，每次将<code>redo log buffer</code>中的日志写入<code>redo log file</code>的过程中都会调用一次操作系统的<code>fsync</code>操作。</p><blockquote><p>fsync函数：包含在UNIX系统头文件#include 中，用于同步内存中所有已修改的文件数据到储存设备。</p></blockquote><p>在写入的过程中，还需要经过操作系统内核空间的<code>os buffer</code>。redo log日志的写入过程可见下图。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233627611.png" class title="image-20231015233627611"><h3 id="3-2-回滚日志（undo-log）"><a href="#3-2-回滚日志（undo-log）" class="headerlink" title="3.2 回滚日志（undo log）"></a>3.2 回滚日志（undo log）</h3><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231022220250583.png" class title="image-20231022220250583"><p>​当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。<br>​但是undo log不redo log不一样，它属于<strong>逻辑日志</strong>。它对SQL语句执行相关的信息进行记录。当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）；对于每个数据删除操作（delete），回滚时会执行数据插入操作（insert）；对于每个数据更新操作（update），回滚时会执行一个相反的数据更新操作（update），把数据改回去。<strong>undo log由两个作用，一是提供回滚，二是实现MVCC</strong>。</p><h3 id="3-3-二进制日志（bin-log）"><a href="#3-3-二进制日志（bin-log）" class="headerlink" title="3.3 二进制日志（bin log）"></a>3.3 二进制日志（bin log）</h3><p>二进制日志binlog是服务层的日志，还被称为归档日志。binlog主要记录数据库的变化情况，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进二进制日志中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步。<br>这里binlog所存储的内容看起来似乎与redo log很相似，但是其实不然。redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑，比如”给ID&#x3D;2这一行的a字段加1 “。binlog日志中的内容是二进制的，根据日记格式参数的不同，可能基于SQL语句、基于数据本身或者二者的混合。一般常用记录的都是SQL语句。</p><p>同时，redo log是基于<code>crash recovery</code>，保证MySQL宕机后的数据恢复；而binlog是基于<code>point-in-time recovery</code>，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份。<br>事实上最开始MySQL是没有redo log日志的。因为起先MySQL是没有InnoDB引擎的，自带的引擎是MyISAM。binlog是服务层的日志，因此所有引擎都能够使用。但是光靠binlog日志只能提供归档的作用，无法提供<code>crash-safe</code>能力，所以InnoDB引擎就采用了学自于Oracle的技术，也就是redo log，这才拥有了<code>crash-safe</code>能力。这里对redo log日志和binlog日志的特点分别进行了对比：</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233948808.png" class title="image-20231015233948808"><p>在MySQL执行更新语句时，都会涉及到redo log日志和binlog日志的读写。一条更新语句的执行过程如下：</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015233957539.png" class title="image-20231015233957539"><p>从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。<br>不仅如此，在对redo log写入时有两个阶段的提交，<strong>一是binlog写入之前prepare状态的写入</strong>，<strong>二是binlog写入之后commit状态的写入</strong>。<br>之所以要安排这么一个<strong>两阶段提交</strong>，自然是有它的道理的。现在我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入redo log，后写入binlog；要么先写入binlog，后写入redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p><h5 id="先写入redo-log，后写入binlog"><a href="#先写入redo-log，后写入binlog" class="headerlink" title="先写入redo log，后写入binlog"></a>先写入redo log，后写入binlog</h5><p>在写完redo log之后，数据此时具有crash-safe能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在redo log写完时候，binlog写入之前，系统发生了宕机。此时binlog没有对上面的更新语句进行保存，导致当使用binlog进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得<code>id=2</code>这一行的数据没有被更新。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231015234018336.png" class title="image-20231015234018336"><p>由此可见，两阶段的提交就是为了避免上述的问题，使得binlog和redo log中保存的信息是一致的。</p><h3 id="4-主从复制"><a href="#4-主从复制" class="headerlink" title="4.主从复制"></a>4.主从复制</h3><p>主从复制的概念很简单，就是从原来的数据库复制一个完全一样的数据库，原来的数据库称作主数据库，复制的数据库称为从数据库。从数据库会与主数据库进行数据同步，保持二者的数据一致性。</p><p>主从复制的原理实际上就是通过bin log日志实现的。bin log日志中保存了数据库中所有SQL语句，通过对bin log日志中SQL的复制，然后再进行语句的执行即可实现从数据库与主数据库的同步。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%932/image-20231016230053131.png" class title="image-20231016230053131"><p>主从复制的过程主要是靠三个线程进行的，一个运行在主服务器中的发送线程，用于发送binlog日志到从服务器。两外两个运行在从服务器上的I&#x2F;O线程和SQL线程。I&#x2F;O线程用于读取主服务器发送过来的binlog日志内容，并拷贝到本地的中继日志中。SQL线程用于读取中继日志中关于数据更新的SQL语句并执行，从而实现主从库的数据一致。</p><p>主从复制能够带来的好处有：</p><blockquote><ol><li>通过复制实现数据的异地备份，当主数据库故障时，可切换从数据库，避免数据丢失。</li><li>可实现架构的扩展，当业务量越来越大，I&#x2F;O访问频率过高时，采用多库的存储，可以降低磁盘I&#x2F;O访问的频率，提高单个机器的I&#x2F;O性能。</li><li>可实现读写分离，使数据库能支持更大的并发。</li><li>实现服务器的负载均衡，通过在主服务器和从服务器之间切分处理客户查询的负荷。</li></ol></blockquote><h3 id="5-备注"><a href="#5-备注" class="headerlink" title="5.备注"></a>5.备注</h3><p>以上资料来源于<a href="https://developer.aliyun.com/article/764178">为了让你彻底弄懂 MySQL 事务日志，我通宵赶出了这份图解！-阿里云开发者社区 (aliyun.com)</a>和<a href="https://www.bilibili.com/video/BV1wu4y1d734/?spm_id_from=333.880.my_history.page.click&vd_source=0fb3165118535b2ba15fe8d267120151">动画讲解：MySQL的MVCC原理，RR不能完全解决幻读问题的底层原理，Undo版本链_哔哩哔哩_bilibili</a>有兴趣的友友可以去看原文和视频</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库1</title>
    <link href="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/"/>
    <url>/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库1"><a href="#数据库1" class="headerlink" title="数据库1"></a>数据库1</h1><h2 id="1-三大范式（设计数据库表会用）"><a href="#1-三大范式（设计数据库表会用）" class="headerlink" title="1.三大范式（设计数据库表会用）"></a>1.三大范式（设计数据库表会用）</h2><p>三大范式是 Mysql 数据库设计表结构所遵循的规范和指导方法，目的是为了减少冗余，建立结构合理的数据库，从而提高数据存储和使用的性能。</p><h3 id="1-1-第一范式"><a href="#1-1-第一范式" class="headerlink" title="1.1 第一范式"></a>1.1 第一范式</h3><p>遵循原子性，即<strong>表中字段数据，不可再分</strong></p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014141600771.png" class title="image-20231014141600771"><p>姓名可再分</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014141653019.png" class title="image-20231014141653019"><h3 id="1-2-第二范式"><a href="#1-2-第二范式" class="headerlink" title="1.2 第二范式"></a>1.2 第二范式</h3><p>在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，<strong>表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</strong>再通俗点讲就是，<strong>一个表只能描述一件事情</strong>。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014141825547.png" class title="image-20231014141825547"><p>我们先分析一下表结构。</p><ol><li>假设学号是表中的唯一主键，那由学号就可以确定姓名和年龄了，但是却不能确定课程名称和成绩。</li><li>假设课程名称是表中的唯一主键，那由课程名称就可以确定学分了，但是却不能确定姓名、年龄和成绩。</li><li>虽然通过学号和课程名称的联合主键，可以确定除联合主键外的所有的非主键值，但是基于上述两个假设，也不符合第二范式的要求。</li></ol><p>我们可以<strong>基于上述的三种主键的可能，拆分成 3 张表，保证一张表只描述一件事情</strong>。</p><ol><li>学生表 - 学号做主键</li></ol><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142006760.png" class title="image-20231014142006760"><p>2.课程表 - 课程名称做主键</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142025456.png" class title="image-20231014142025456"><p>3.成绩表 - 学号和课程名称做联合主键</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142043835.png" class title="image-20231014142043835"><p>这时候我们可能会想，为什么我们就要遵循第二范式呢？<strong>不遵循第二范式会造成什么样的后果呢</strong>？</p><ol><li><strong>造成整表的数据冗余。</strong></li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li><strong>更新数据不方便。</strong></li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li><strong>插入数据不方便或产生异常。</strong></li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p><h3 id="1-3-第三范式"><a href="#1-3-第三范式" class="headerlink" title="1.3 第三范式"></a>1.3 第三范式</h3><p>在满足第二范式的情况下，消除传递依赖。即，<strong>在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B</strong>。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142159340.png" class title="image-20231014142159340"><p>这个表中，学号是主键，它可以唯一确定姓名、班级、班主任，符合了第二范式，但是在非主键字段中，我们也可以通过班级推导出该班级的班主任，所以它是不符合第三范式的。</p><p>那怎么设计表结构，才是符合第三范式的呢？</p><p>1.学生表</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142228435.png" class title="image-20231014142228435"><p>2.班级表</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014142240158.png" class title="image-20231014142240158"><p>通过把班级与班主任的映射关系另外做成一张映射表，我们就成功地消除了表中的传递依赖了。</p><h2 id="2-数据库语言"><a href="#2-数据库语言" class="headerlink" title="2.数据库语言"></a>2.数据库语言</h2><p><strong>数据查询语言（DQL）：</strong>用来查询记录。保留字：select、where、order by、group by、having（where不能加聚合函数，通过having加，group by后面跟having）。</p><p><strong>数据操作语言（DML）：</strong>用来操纵数据库记录。保留字：insert、update、delete。</p><p><strong>数据定义语言（DDL）：</strong>用来定义数据库的表、库、列等对象。保留字：create、alter、drop、truncate</p><p><strong>数据控制语言（DCL）：</strong>用来定义访问权限和安全级别。保留字：commit，rollback、savepoint、grant、revoke</p><p>易考点：</p><p>1.delete ，delete from student order by math desc limit 3；标记为删除没真删，DML，用来删部分数据</p><p>2.truncate，truncate table_name ；DDL，本质是新建一个表结构并删除之前的，DDL，删除所有行数据</p><p>3.drop，drop table_name；DDL，本质是行数据+表结构一起删除</p><p>4.分页查询：select 字段名 from 表 limit 初始位置，记录条数</p><p>5.insert into std (id,name,score) values(xxxxxx)</p><p>6.delete from stu where</p><p>7.update stu set name&#x3D;xxx,where name&#x3D;xx</p><p>SQL语句的连接分为内连接、外连接</p><p>内连接：利用条件表达式来消除交叉连接，如果没有连接条件就和cross join一样，都是在笛卡尔积商上进行处理</p><p>外连接：分为左外连接、右外连接、全连接（mysql没有）</p><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3.索引"></a>3.索引</h2><h3 id="3-1-用户记录是如何存放的？（索引的引入）"><a href="#3-1-用户记录是如何存放的？（索引的引入）" class="headerlink" title="3.1 用户记录是如何存放的？（索引的引入）"></a>3.1 用户记录是如何存放的？（索引的引入）</h3><p>我们平时都是以记录为单位向MySQL的表中插入数据的，这些记录在磁盘中的存放的格式就是InnoDB的行格式。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151052208.png" class title="image-20231014151052208"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150256129.png" class title="image-20231014150256129"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150341549.png" class title="image-20231014150341549"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150548767.png" class title="image-20231014150548767"><p>最终数据页</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150707242.png" class title="image-20231014150707242"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150823780.png" class title="image-20231014150823780"><p>上图中的所有记录（包括伪记录）分成了4个小组，每个小组的“组长”被单独提拔，单独编制成“目录”，InnoDB官方称之为「<code>槽</code>」。槽在物理空间中是连续的，意味着通过一个槽可以很轻松地找到它的上一个和下一个，这一点非常重要。</p><p>槽的编号从0开始，我们查找数据的时候先找到对应的槽，然后再到小组中进行遍历即可，因为一个小组内的记录数量并不多，遍历的性能损耗可以忽略。而且每个槽代表的“组长”的主键值也是从小到大进行排列的，所以我们可以用二分法进行槽的快速查找。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150843962.png" class title="image-20231014150843962"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014150955225.png" class title="image-20231014150955225"><p>当用户记录多到一个数据页装不下的时候，就再申请一个数据页，各个数据页在逻辑上使用双向链表进行连接，因此新分配的数据页编号就没必要非得按照从小到大的顺序进行排列了</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151137226.png" class title="image-20231014151137226"><p>这时，我们在在一个数据页内能够做到主键的快速查询，但是页号直接的快速查找就不可以了，我们就需要沿着双向链表一直进行查找，所有就引入了索引的概念</p><h3 id="3-2-B-树"><a href="#3-2-B-树" class="headerlink" title="3.2 B+树"></a>3.2 B+树</h3><p>现在一个页面的信息就是这样的</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151549941.png" class title="image-20231014151549941"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151610777.png" class title="image-20231014151610777"><p>进行添加数据页</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152041362.png" class title="image-20231014152041362"><p>最后变成</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152107958.png" class title="image-20231014152107958"><h4 id="3-2-1-聚簇索引"><a href="#3-2-1-聚簇索引" class="headerlink" title="3.2.1 聚簇索引"></a>3.2.1 聚簇索引</h4><p>这就是B+树，最底层的结点被称为<strong>叶子节点</strong>，剩下的就是<strong>非叶节点</strong>，这棵B+树的叶子节点存储了我们完整的用户记录（就是我们插入表的所有数据），而且，这是用户记录在InnoDB引擎中的唯一存储方式。也就是所谓的“<strong>索引即数据，数据即索引</strong>”。这个索引就是<strong>主键索引</strong>，又叫做<strong>聚簇索引</strong>。</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014151838196.png" class title="image-20231014151838196"><h4 id="3-2-2-普通索引"><a href="#3-2-2-普通索引" class="headerlink" title="3.2.2 普通索引"></a>3.2.2 普通索引</h4><p>除了主键索引以外，我们还有<strong>普通索引</strong></p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152530584.png" class title="image-20231014152530584"><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152543616.png" class title="image-20231014152543616"><p>可以看到叶子节点存放的不再是完整的用户记录，而是只记录<code>name</code>列和主键值</p><p>数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照<code>name</code>列排序；</p><p>目录项记录除了存储索引列（<code>name</code>）和页号之外，同时还存储了主键值；</p><p><strong>普通索引查询</strong>时走如下方式</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014152724393.png" class title="image-20231014152724393"><h4 id="3-2-3-联合索引"><a href="#3-2-3-联合索引" class="headerlink" title="3.2.3 联合索引"></a>3.2.3 联合索引</h4><p>先对name进行排序，然后name相同时再对age，可以看到name有序，age无序</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014153048054.png" class title="image-20231014153048054"><p>数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照<code>name</code>列排序，如果<code>name</code>列相同，那就按照<code>phone</code>列排序；</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014153109952.png" class title="image-20231014153109952"><p>最后回表查询</p><img src="/2023/10/14/%E6%95%B0%E6%8D%AE%E5%BA%931/image-20231014153242173.png" class title="image-20231014153242173"><p>这也就解释了为什么索引是<strong>最左匹配原则</strong>，因为在底层的时候就是从左到右边按序排列的</p><h3 id="4-备注"><a href="#4-备注" class="headerlink" title="4.备注"></a>4.备注</h3><p>本文引用了知乎<a href="https://zhuanlan.zhihu.com/p/479164948">彻底搞懂MySQL的主键索引、普通索引和联合索引 - 知乎 (zhihu.com)</a>以及<a href="https://www.bilibili.com/video/BV1au4y1D7Qj/?spm_id_from=333.999.0.0&vd_source=0fb3165118535b2ba15fe8d267120151">动画演示：用最简单直白的方式讲解MySQL的主键索引、普通索引和联合索引_哔哩哔哩_bilibili</a>的讲解，图片非常清晰感兴趣的友友们可以去看</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP相关知识</title>
    <link href="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h1><h2 id="1-键入网址到网页显示"><a href="#1-键入网址到网页显示" class="headerlink" title="1.键入网址到网页显示"></a>1.键入网址到网页显示</h2><p>1.浏览器做的第一步工作是解析 URL，对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p><p>2.进行DNS解析（递归和迭代）：将域名解析成IP地址</p><p>3.通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>4.在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>5.TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><p>6.生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p><p>7.网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>8.交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>9.网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>10.数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>11.浏览器解析渲染页面</p><p>12.TCP四次挥手</p><h2 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2.HTTP报文"></a>2.HTTP报文</h2><h3 id="2-1-HTTP请求报文"><a href="#2-1-HTTP请求报文" class="headerlink" title="2.1 HTTP请求报文"></a>2.1 HTTP请求报文</h3><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012205223836.png" class title="image-20231012205223836"><p>真实数据</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210136196.png" class title="image-20231012210136196"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210300986.png" class title="image-20231012210300986"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210358855.png" class title="image-20231012210358855"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012210644840.png" class title="image-20231012210644840"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211018848.png" class title="image-20231012211018848"><h3 id="2-2-HTTP响应报文"><a href="#2-2-HTTP响应报文" class="headerlink" title="2.2 HTTP响应报文"></a>2.2 HTTP响应报文</h3><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211123361.png" class title="image-20231012211123361"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211439888.png" class title="image-20231012211439888"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211513618.png" class title="image-20231012211513618"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211538145.png" class title="image-20231012211538145"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211801367.png" class title="image-20231012211801367"><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012211554409.png" class title="image-20231012211554409"><h2 id="3-HTTP和HTTPS的区别"><a href="#3-HTTP和HTTPS的区别" class="headerlink" title="3.HTTP和HTTPS的区别"></a>3.HTTP和HTTPS的区别</h2><p>HTTP 是一种 <code>超文本传输协议(Hypertext Transfer Protocol)</code>，<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012212923334.png" class title="image-20231012212923334"><p>而 HTTPS 的全称是 <code>Hypertext Transfer Protocol Secure</code>，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 <strong>HTTP + TLS&#x2F;SSL 协议</strong>组合而成，而安全性的保证正是 TLS&#x2F;SSL 所做的工作。</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012212954347.png" class title="image-20231012212954347"><p>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；</p><p>而 HTTPS 是安全的协议，它通过 <strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong> 能够解决上面这些问题。</p><p>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443</p><h2 id="4-HTTPS的工作原理"><a href="#4-HTTPS的工作原理" class="headerlink" title="4.HTTPS的工作原理"></a>4.HTTPS的工作原理</h2><p>我们探讨 HTTPS 的握手过程，其实就是 SSL&#x2F;TLS 的握手过程。</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012214122997.png" class title="image-20231012214122997"><h2 id="5-HTTP-Get和Post区别"><a href="#5-HTTP-Get和Post区别" class="headerlink" title="5.HTTP Get和Post区别"></a>5.HTTP Get和Post区别</h2><p>1.Get 方法一般用于请求，比如你在浏览器地址栏输入 <code>www.cxuanblog.com</code> 其实就是发送了一个 Get 请求，它的主要特征是请求服务器返回资源，而 Post 方法一般用于 <code>&lt;form&gt; 表单</code>的提交，相当于是把信息提交给服务器，等待服务器作出响应，Get 相当于一个是 pull&#x2F;拉的操作，而 Post 相当于是一个 push&#x2F;推的操作。</p><p>2.Get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造,post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p><p>3.Get 请求的 URL 有长度限制，而Post 请求会把参数和值放在消息体中，对数据长度没有要求。</p><p>4.Get 请求在发送过程中会产生一个 TCP 数据包；Post 在发送过程中会产生两个 TCP 数据包。对于 Get 方式的请求，浏览器会把 Gttp Header 和 Data 一并发送出去，服务器响应 200（返回数据）；而对于 Post，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送 Data，服务器响应 200 ok（返回数据）。</p><p>5.Post能发送更多的数据类型（Get只能发送ASCII字符）</p><h2 id="6-什么是无状态协议，HTTP-是无状态协议吗，怎么解决"><a href="#6-什么是无状态协议，HTTP-是无状态协议吗，怎么解决" class="headerlink" title="6.什么是无状态协议，HTTP 是无状态协议吗，怎么解决"></a>6.什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h2><p>无状态协议(Stateless Protocol) 就是指<strong>浏览器对于事务的处理没有记忆能力</strong>。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p><p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 <strong>小甜饼(Cookie)<strong>的机制。它能够让浏览器具有</strong>记忆</strong>能力。</p><p>当你想服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012215048011.png" class title="image-20231012215048011"><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012215809720.png" class title="image-20231012215809720"><p>7.Cookie与Session区别</p><p>(1) cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2) cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3) session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4) 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5) 所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p><h2 id="7-HTTP常见请求头"><a href="#7-HTTP常见请求头" class="headerlink" title="7.HTTP常见请求头"></a>7.HTTP常见请求头</h2><p>通用标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220255825.png" class title="image-20231012220255825"><p>实体标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220308488.png" class title="image-20231012220308488"><p>请求标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220321081.png" class title="image-20231012220321081"><p>响应标头</p><img src="/2023/10/12/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20231012220333020.png" class title="image-20231012220333020">]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>liunx-IO</title>
    <link href="/2023/10/10/liunx-IO/"/>
    <url>/2023/10/10/liunx-IO/</url>
    
    <content type="html"><![CDATA[<h1 id="Liunx-IO"><a href="#Liunx-IO" class="headerlink" title="Liunx-IO"></a>Liunx-IO</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><h3 id="1-1-Liunx的组成"><a href="#1-1-Liunx的组成" class="headerlink" title="1.1 Liunx的组成"></a>1.1 Liunx的组成</h3><p>如下图所示，Liunx系统包含了内核、Shell、文件系统、应用系统</p><img src="/2023/10/10/liunx-IO/image-20231010223007225.png" class title="image-20231010223007225"><p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p><p><strong>系统调用接口：</strong>SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p><img src="/2023/10/10/liunx-IO/image-20231010223213876.png" class title="image-20231010223213876"><h3 id="1-2-用户空间与内核空间"><a href="#1-2-用户空间与内核空间" class="headerlink" title="1.2 用户空间与内核空间"></a>1.2 用户空间与内核空间</h3><p>对于Linux操作系统而言，其核心是内核，内核独立于普通的应用程序。操作系统为了支持多个应用同时进行，需保证不同进程之间的相对独立（一个进程崩溃不会影响其他进程，恶意进程不能直接读取或修改其他进程运行时的代码或数据）。因此操作系统内核需要用有比普通进程更高的权限，以此来调度和管理用户的应用程序，同时也可以保证内核的安全。</p><p>因此内存空间被划分为内核空间、用户空间。内核可以访问受保护的内核空间，也有访问底层硬件设备的所有权限。</p><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><img src="/2023/10/10/liunx-IO/image-20231010223620882.png" class title="image-20231010223620882"><h3 id="1-3-进程切换"><a href="#1-3-进程切换" class="headerlink" title="1.3 进程切换"></a>1.3 进程切换</h3><p>为了管理进程，内核必须有挂起、恢复某个进程的能力。此种行为称为上下文切换。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">保存CPU上下文信息，包括程序计数器、其他寄存器<br>更新PCB信息<br>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列<br>选择另一个进程执行，并更新其PCB<br>更新内存管理的数据结构<br></code></pre></td></tr></table></figure><p>总结：上下文切换需要进行一系列复杂的操作，很消耗资源</p><h3 id="1-4-进程的阻塞"><a href="#1-4-进程的阻塞" class="headerlink" title="1.4 进程的阻塞"></a>1.4 进程的阻塞</h3><p><strong>正在执行的进程，当它无法获取到所需的资源（比如请求系统资源失败、等待某种操作完成、新数据尚未到达或无新的工作任务），则由系统执行阻塞原语（Block），使自己由运行状态变为阻塞状态。</strong> 只有处于运行态的进程才可能将其转为阻塞状态。阻塞态的进程不占用CPU资源。</p><h3 id="1-5-文件与文件描述符"><a href="#1-5-文件与文件描述符" class="headerlink" title="1.5 文件与文件描述符"></a>1.5 文件与文件描述符</h3><p>Linux中一切皆文件，包括普通文件、套接字、字符设备文件（键盘、鼠标等等）、块设备文件（光驱、硬盘），这些都抽象成文件</p><p>文件描述符，File Descriptor，简称fd。其本质是一个非负整数。当程序打开或创建一个文件，内核都会返回一个非负整数，即文件描述符。此非负整数对应内核为每个进程所维护的该进程打开文件的记录表中的一条记录，即非负整数对应一个表上的一条记录。如下图所示：</p><img src="/2023/10/10/liunx-IO/image-20231010224322534-1697161520610-5.png" class title="image-20231010224322534"><p>如上图所示，进程A中文件描述符1和3都指向同一个句柄13，这可能是该进程A多次执行打开同一个文件操作。</p><p>总结：进程拿到文件描述符，去进程对应的文件描述符表查询到文件指针，文件指针指向系统级别的打开文件表的文件偏移量，通过文件偏移量拿到i-node指针，最终找到真实的文件。</p><p><strong>小结：</strong></p><p>当用户打开一个文件，用户只得到了一个 <code>fd</code> 句柄，但内核做了很多事情，梳理下来，我们得到几个关键的数据结构，这几个数据结构是有层次递进关系的，我们简单梳理下：</p><ol><li>进程结构 <code>task_struct</code> ：表征进程实体，每一个进程都和一个 <code>task_struct</code> 结构体对应，其中 <code>task_struct.files</code> 指向一个管理打开文件的结构体 <code>fiels_struct</code> ；</li><li>文件表项管理结构 <code>files_struct</code> ：用于管理进程打开的 open 文件列表，内部以数组的方式实现（静态数组和动态数组结合）。返回给用户的 <code>fd</code> 就是这个数组的<strong>编号索引</strong>而已，索引元素为 <code>file</code> 结构；</li></ol><ul><li><strong><code>files_struct</code> 只从属于某进程；</strong></li></ul><p>​文件 <code>file</code> 结构：表征一个打开的文件，内部包含关键的字段有：<strong>当前文件偏移，inode 结构地址</strong>；</p><ul><li><strong>该结构虽然由进程触发创建，但是 <code>file</code> 结构可以在进程间共享；</strong></li></ul><p>​<code>vfs inode</code> 结构体：文件 <code>file</code> 结构指向 的是 vfs 的 <code>inode</code> ，这个是操作系统抽象出来的一层，用于屏蔽后端各种各样的文件系统的 <code>inode</code> 差异；</p><ul><li><strong>inode 这个具体进程无关，是文件系统级别的资源；</strong></li></ul><p>​<code>ext4 inode</code> 结构体（指代具体文件系统 inode ）：后端文件系统的 <code>inode</code> 结构，不同文件系统自定义的结构体，ext2 有 <code>ext2_inode_info</code>，ext4 有<code>ext4_inode_info</code>，minix 有 <code>minix_inode_info</code>，这些结构里都是内嵌了一个 vfs <code>inode</code> 结构体，原理相同；</p><img src="/2023/10/10/liunx-IO/image-20231010224514222-1697161551998-7.png" class title="image-20231010224514222"><p><strong>Liunx内核的VFS子系统</strong></p><img src="/2023/10/10/liunx-IO/image-20231010225314350.png" class title="image-20231010225314350"><p>​文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。</p><p>​在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是<strong>对应不同的file结构体，因此可以有不同的File Status Flag和读写位置</strong>。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。</p><p>​每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。</p><p>​file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p><p>​每个file结构体都有一个指向dentry结构体的指针，<strong>“dentry”是directory entry（目录项）的缩写</strong>。我们传给open、stat等函数的参数的是一个路径，例如&#x2F;home&#x2F;akaedu&#x2F;a，需要根据路径找到文件的inode。<strong>为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache</strong>，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录&#x2F;找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p><p>​每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示&#x2F;home&#x2F;akaedu&#x2F;a和&#x2F;home&#x2F;akaedu&#x2F;b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。</p><p>​和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。</p><p>​inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到&#x2F;home目录下。</p><p>​file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p><h3 id="1-6-缓存IO"><a href="#1-6-缓存IO" class="headerlink" title="1.6 缓存IO"></a>1.6 缓存IO</h3><p>缓存IO又被称作标准IO，在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中（page cache）。即数据先被拷贝到内核的缓冲区中，随后才会被拷贝到应用程序的地址空间。</p><p>优点：可以解决CPU与IO速度冲突问题</p><p>缺点：数据传输过程中，数据在进程的<strong>地址空间与内核空间进行多次数据拷贝操作</strong>，CPU以及内存开销都很大。</p><p>总结：网络IO就是操作系统接收网卡收到的数据，缓存到一个buffer中，应用程序调用操作系统的函数（就是操作系统提供的IO接口），从对应的buffer中取出数据。操作系统在网络IO过程中充当了一个提供抽象接口的角色</p><h2 id="2-Liunx-IO模型"><a href="#2-Liunx-IO模型" class="headerlink" title="2.Liunx IO模型"></a>2.Liunx IO模型</h2><p>网络IO的本质是socket的读取，socket会被Linux抽象成流，IO可以看作是对流的操作。以Read举例子，对于一次IO访问，<strong>数据先被拷贝到内核的缓冲区中，然后才从操作系统内核的缓冲区中拷贝到应用程序的地址空间</strong>。</p><p>当发生一次Read操作时，会发生以下2个阶段：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">等待数据准备<br>将数据从内核拷贝到进程中<br></code></pre></td></tr></table></figure><p>对于Socket流而言，发生如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">通常等待网络上其他数据分组到达，然后被复制到内核的某个缓冲区中<br>把数据从内核的缓冲区复制到应用进程缓冲区<br></code></pre></td></tr></table></figure><p>网络IO有如下几种：</p><ul><li>同步模型（synchronous IO）</li><li>阻塞IO（blocking IO）</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li><li>异步IO（asynchronous IO）</li></ul><h3 id="2-1-同步阻塞IO"><a href="#2-1-同步阻塞IO" class="headerlink" title="2.1 同步阻塞IO"></a>2.1 同步阻塞IO</h3><p>用户空间的进程执行一个系统调用，比如recvfrom，这会导致应用程序阻塞，期间什么都不干，直到数据准备好，并且数据被从内核缓冲区复制到用户进程</p><img src="/2023/10/10/liunx-IO/image-20231011093416174.png" class title="image-20231011093416174"><p>如上图所示，用户进程调用recvfrom这个系统调用，内核即开始IO的第一个阶段，对于网络IO来说，此时还未收到一个完整的数据包，通常需要等待其他数据报到来组成一个完整的数据包。这个过程是数据被复制到内核的某个缓冲区中。此时用户进程会自行阻塞。复制完后，进入第二个阶段。<strong>内核一直等到数据准备好了</strong>，就把数据从内核复制到用户空间。内核返回结果，用户进程解除阻塞状态，重新运行起来。</p><img src="/2023/10/10/liunx-IO/image-20231011111441664.png" class title="image-20231011111441664"><h3 id="2-2-同步非阻塞IO"><a href="#2-2-同步非阻塞IO" class="headerlink" title="2.2 同步非阻塞IO"></a>2.2 同步非阻塞IO</h3><p>用户进程调用recvfrom系统调用，进程没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时返回一个error。进程收到返回后做些别的事请，过一会再发起recvfrom系统调用。如此循环重复，此过程常称为轮询。直到数据准备好并且已经被复制到用户空间。如下图所示：</p><img src="/2023/10/10/liunx-IO/image-20231011095934835.png" class title="image-20231011095934835"><p>用户进程发出recvfrom操作，用户进程不会被阻塞，内核若还未准备好数据，则会返回一个error。<strong>此时用户进程可以干别的事请，过一会再调用recvfrom询问内核是否准备好了数据，此操作称为轮询</strong>。一旦内核准备好了数据并且用户进程前来询问，此时内核将数据复制到用户空间中并且返回。</p><h3 id="2-3-IO多路复用"><a href="#2-3-IO多路复用" class="headerlink" title="2.3 IO多路复用"></a>2.3 IO多路复用</h3><p>同步非阻塞IO是由用户进程去轮询内核是否准备好了数据。IO多路复用则使用<strong>一个特定的进程去轮询</strong>。这就是IO多路复用。常见的select、poll、epoll就是干这个的。select调用是内核级别的。select与同步非阻塞的区别在于：前者能等待多个socket，即能同时监听多个IO端口。当内核对任何一个socket准备好了部分数据（select无需等所有数据包到达内核后才开始，内核会负责监视是否有数据到达）就能返回，然后用户进程再进行recvfrom调用，将数据从内核复制到用户空间。</p><p>select、poll、epoll可以同时阻塞多个IO操作。直到内核监视到有数据到达内核，才真正调用IO操作函数。</p><img src="/2023/10/10/liunx-IO/image-20231011103101687.png" class title="image-20231011103101687"><p>IO multiplexing就是常说的select、poll、epoll。好处是用一个进程即可处理多个网络连接的IO。其原理是select、poll、epoll不断地轮询负责的socket，当某个socket有数据到达内核，就通知用户进程。</p><p>用户进程调用select，整个进程会被阻塞。内核监视select负责的所有socket，任何一个有数据准备好，select就返回。此时用户再调用recvfrom，将数据从内核拷贝到用户进程。</p><h4 id="2-3-1-select原理"><a href="#2-3-1-select原理" class="headerlink" title="2.3.1 select原理"></a><strong>2.3.1 select原理</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds,                     <span class="hljs-comment">// 监控的文件描述符集里最大文件描述符加1</span></span><br><span class="hljs-params">    fd_set *readfds,              <span class="hljs-comment">// 监控有读数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *writefds,             <span class="hljs-comment">// 监控写数据到达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    fd_set *exceptfds,            <span class="hljs-comment">// 监控异常发生达文件描述符集合，引用类型的参数</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout)</span>;     <span class="hljs-comment">// 定时阻塞监控时间</span><br></code></pre></td></tr></table></figure><p>readfds、writefds、errorfds 是三个文件描述符集合。select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换这三个引用参数中的对应集合，返回所有就绪描述符的数量。</p><p>timeout 参数表示调用 select 时的阻塞时长。如果所有 fd 文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。</p><p><strong>fd_set 文件描述符集合</strong></p><p>select 函数参数中的 fd_set 类型表示文件描述符的集合。</p><p>由于文件描述符 fd 是一个从 0 开始的无符号整数，所以可以使用 fd_set 的二进制每一位来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 fd_set 长度为 1 字节，则一个 fd_set 变量最大可以表示 8 个文件描述符。当 select 返回 fd_set &#x3D; 00010011 时，表示文件描述符 1、2、5 已经就绪。</p><img src="/2023/10/10/liunx-IO/image-20231011112434243.png" class title="image-20231011112434243"><img src="/2023/10/10/liunx-IO/image-20231011213646817.png" class title="image-20231011213646817"><h4 id="2-3-2-epoll实现原理"><a href="#2-3-2-epoll实现原理" class="headerlink" title="2.3.2 epoll实现原理"></a>2.3.2 epoll实现原理</h4><p>epoll 的特点是：</p><p>1）使用<strong>红黑树</strong>存储<strong>一份</strong>文件描述符集合，每个文件描述符只需在添加时传入一次，无需用户每次都重新传入；—— 解决了 select 中 fd_set 重复拷贝到内核的问题</p><p>2）通过异步 IO 事件找到就绪的文件描述符，而不是通过轮询的方式；</p><p>3）使用队列存储就绪的文件描述符，且会按需返回就绪的文件描述符，无须再次遍历；</p><p><strong>epoll_ctl</strong></p><p>epoll_ctl 函数主要负责把服务端和客户端建立的 socket 连接注册到 eventpoll 对象里，会做三件事：</p><p>1）创建一个 epitem 对象，主要包含两个字段，分别存放 socket fd 即连接的文件描述符，和所属的 eventpoll 对象的指针；</p><p>2）将一个数据到达时用到的回调函数添加到 socket 的进程等待队列中，注意，跟第 1.1 节的阻塞 IO 模式不同的是，这里添加的 socket 的进程等待队列结构中，只有回调函数，没有设置进程描述符，因为<strong>在 epoll 中，进程是放在 eventpoll 的等待队列中</strong>，等待被 epoll_wait 函数唤醒，而不是放在 socket 的进程等待队列中；</p><p>3）将第 1）步创建的 epitem 对象插入红黑树；</p><img src="/2023/10/10/liunx-IO/image-20231011215103788.png" class title="image-20231011215103788"><p><strong>epoll_wait</strong></p><p>epoll_wait 函数的动作比较简单，检查 eventpoll 对象的就绪的连接 rdllist 上是否有数据到达，如果没有就把当前的进程描述符添加到一个等待队列项里，加入到 eventpoll 的进程等待队列里，然后阻塞当前进程，等待数据到达时通过回调函数被唤醒。</p><p>当 eventpoll 监控的连接上有数据到达时，通过下面几个步骤唤醒对应的进程处理数据：</p><p>1）socket 的数据接收队列有数据到达，会通过进程等待队列的回调函数 ep_poll_callback 唤醒红黑树中的节点 epitem；</p><p>2）ep_poll_callback 函数将有数据到达的 epitem 添加到 eventpoll 对象的就绪队列 rdllist 中；</p><p>3）ep_poll_callback 函数检查 eventpoll 对象的进程等待队列上是否有等待项，通过回调函数 default_wake_func 唤醒这个进程，进行数据的处理；</p><p>4）当进程醒来后，继续从 epoll_wait 时暂停的代码继续执行，把 rdlist 中就绪的事件返回给用户进程，让用户进程调用 recv 把已经到达内核 socket 等待队列的数据拷贝到用户空间使用。</p><img src="/2023/10/10/liunx-IO/image-20231011220001774.png" class title="image-20231011220001774"><h4 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3 总结"></a>2.3.3 总结</h4><p>从阻塞 IO 到 epoll 的实现中，我们可以看到 <strong>wake up 回调函数机制</strong>被频繁的使用，至少有三处地方：一是阻塞 IO 中数据到达 socket 的等待队列时，通过回调函数唤醒进程，二是 epoll 中数据到达 socket 的等待队列时，通过回调函数 ep_poll_callback 找到 eventpoll 中红黑树的 epitem 节点，并将其加入就绪列队 rdllist，三是通过回调函数 default_wake_func 唤醒用户进程 ，并将 rdllist 传递给用户进程，让用户进程准确读取数据 。从中可知，这种回调机制能够定向准确的通知程序要处理的事件，而不需要每次都循环遍历检查数据是否到达以及数据该由哪个进程处理，提高了程序效率，在日常的业务开发中，我们也可以借鉴下这一机制。</p><h3 id="2-4-信号驱动式IO"><a href="#2-4-信号驱动式IO" class="headerlink" title="2.4 信号驱动式IO"></a>2.4 信号驱动式IO</h3><img src="/2023/10/10/liunx-IO/image-20231012105822167.png" class title="image-20231012105822167"><h3 id="2-5-异步IO"><a href="#2-5-异步IO" class="headerlink" title="2.5 异步IO"></a>2.5 异步IO</h3><img src="/2023/10/10/liunx-IO/image-20231012105909004.png" class title="image-20231012105909004"><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p><strong>同步：</strong>发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 例如：B&#x2F;S模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。</p><p><strong>异步：</strong>异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>对于通知调用者的三种方式，具体如下：</p><ul><li>状态</li></ul><p>即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p><ul><li>通知</li></ul><p>当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p><ul><li>回调</li></ul><p>与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p><p>例如：B&#x2F;S模式中的ajax请求，具体过程是：客户端发出ajax请求-&gt;服务端处理-&gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。</p><p><strong>总结来说，同步和异步的区别：请求发出后，是否需要等待结果，才能继续执行其他操作。</strong></p><p><strong>阻塞：</strong>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p><strong>非阻塞：</strong>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>总体来说：阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</strong></p><p><strong>同步阻塞</strong>：小明一直盯着下载进度条，到 100% 的时候就完成。 - 同步体现在：等待下载完成通知。 - 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理。</p><p><strong>同步非阻塞</strong>：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。 - 同步体现在：等待下载完成通知。 - 非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条。【小明必须要在两个任务间切换，关注下载进度】</p><p><strong>异步阻塞</strong>：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明不做别的事，仍然一直等待“叮”的声音。 - 异步体现在：下载完成“叮”一声通知。 - 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理。</p><p><strong>异步非阻塞</strong>：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 - 异步体现在：下载完成“叮”一声通知。 - 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-liunx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>liunx命令</title>
    <link href="/2023/10/08/liunx%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/10/08/liunx%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="liunx命令"><a href="#liunx命令" class="headerlink" title="liunx命令"></a>liunx命令</h1><h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1.文件结构"></a>1.文件结构</h2><table><thead><tr><th>文件</th><th align="left">描述</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td align="left">二进制文件</td></tr><tr><td>&#x2F;boot</td><td align="left">系统启动分区</td></tr><tr><td>&#x2F;dev</td><td align="left">设备文件</td></tr><tr><td>&#x2F;etc</td><td align="left">大多数配置文件</td></tr><tr><td>&#x2F;home</td><td align="left">普通用户的家目录</td></tr><tr><td>&#x2F;lib</td><td align="left">32位函数库</td></tr><tr><td>&#x2F;lib64</td><td align="left">64位库</td></tr><tr><td>&#x2F;media</td><td align="left">手动临时挂载点</td></tr><tr><td>&#x2F;mnt</td><td align="left">手动临时挂载点</td></tr><tr><td>&#x2F;opt</td><td align="left">第三方软件安装位置</td></tr><tr><td>&#x2F;proc</td><td align="left">进程信息及硬件信息</td></tr><tr><td>&#x2F;sbin</td><td align="left">系统管理命令</td></tr><tr><td>&#x2F;srv</td><td align="left">数据</td></tr><tr><td>&#x2F;var</td><td align="left">数据</td></tr><tr><td>&#x2F;sys</td><td align="left">内核相关信息</td></tr><tr><td>&#x2F;tmp</td><td align="left">临时文件</td></tr><tr><td>&#x2F;usr</td><td align="left">用户相关设定</td></tr></tbody></table><h2 id="2-命令行含义"><a href="#2-命令行含义" class="headerlink" title="2.命令行含义"></a>2.命令行含义</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">示例：root@app00:~# <br>root    //用户名，root为超级用户<br>@       //分隔符<br>app00   //主机名称<br>~       //当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下）<br><span class="hljs-meta prompt_"># </span><span class="language-bash">     //表示当前用户是超级用户，普通用户为$，例如：（<span class="hljs-string">&quot;yao@app00:/root$&quot;</span> ，表示使用用户<span class="hljs-string">&quot;yao&quot;</span>访问/root文件夹）</span><br></code></pre></td></tr></table></figure><h2 id="3-目录操作"><a href="#3-目录操作" class="headerlink" title="3.目录操作"></a>3.目录操作</h2><h3 id="3-1-切换目录（cd）"><a href="#3-1-切换目录（cd）" class="headerlink" title="3.1 切换目录（cd）"></a>3.1 切换目录（cd）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /                 //切换到根目录<br>cd /bin              //切换到根目录下的bin目录<br>cd ../               //切换到上一级目录 或者使用命令：cd ..<br>cd ~                 //切换到home目录<br>cd -                 //切换到上次访问的目录<br>cd xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错<br>cd /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全<br></code></pre></td></tr></table></figure><h3 id="3-2-查看目录（ls）"><a href="#3-2-查看目录（ls）" class="headerlink" title="3.2 查看目录（ls）"></a>3.2 查看目录（ls）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls                   //查看当前目录下的所有目录和文件<br>ls -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令&quot;ll&quot;效果一样<br>ls /bin              //查看指定目录下的所有目录和文件 <br></code></pre></td></tr></table></figure><h3 id="3-3-创建目录（mkdir）"><a href="#3-3-创建目录（mkdir）" class="headerlink" title="3.3 创建目录（mkdir）"></a>3.3 创建目录（mkdir）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir tools          //在当前目录下创建一个名为tools的目录<br>mkdir /bin/tools     //在指定目录下创建一个名为tools的目录<br></code></pre></td></tr></table></figure><h3 id="3-4-修改目录（mv"><a href="#3-4-修改目录（mv" class="headerlink" title="3.4  修改目录（mv)"></a>3.4  修改目录（mv)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 当前目录名 新目录名        //修改目录名，同样适用与文件操作<br>mv /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面<br>mv -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹<br></code></pre></td></tr></table></figure><h3 id="3-5-删除目录与文件（rm）"><a href="#3-5-删除目录与文件（rm）" class="headerlink" title="3.5 删除目录与文件（rm）"></a>3.5 删除目录与文件（rm）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名              //删除当前目录下的文件<br>rm -f 文件名           //删除当前目录的的文件（不询问）<br>rm -r 文件夹名         //递归删除当前目录下此名的目录<br>rm -rf 文件夹名        //递归删除当前目录下此名的目录（不询问）<br>rm -rf *              //将当前目录下的所有目录和文件全部删除<br>rm -rf /*             //将根目录下的所有文件全部删除【慎用！相当于格式化系统】<br></code></pre></td></tr></table></figure><h3 id="3-6-拷贝目录（cp）"><a href="#3-6-拷贝目录（cp）" class="headerlink" title="3.6 拷贝目录（cp）"></a>3.6 拷贝目录（cp）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面<br>cp -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹<br></code></pre></td></tr></table></figure><h3 id="3-7-搜索目录（find）"><a href="#3-7-搜索目录（find）" class="headerlink" title="3.7 搜索目录（find）"></a>3.7 搜索目录（find）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /bin -name &#x27;a*&#x27;        //查找/bin目录下的所有以a开头的文件或者目录<br></code></pre></td></tr></table></figure><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h2><h3 id="4-1-新增文件（touch）"><a href="#4-1-新增文件（touch）" class="headerlink" title="4.1 新增文件（touch）"></a>4.1 新增文件（touch）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch  a.txt         //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间<br>vim a.txt<br>cat &lt; daygeek4.txt<br></code></pre></td></tr></table></figure><h3 id="4-2-删除文件（rm）"><a href="#4-2-删除文件（rm）" class="headerlink" title="4.2 删除文件（rm）"></a>4.2 删除文件（rm）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名              //删除当前目录下的文件<br>rm -f 文件名           //删除当前目录的的文件（不询问）<br></code></pre></td></tr></table></figure><h3 id="4-3-编辑文件（vi、vim）"><a href="#4-3-编辑文件（vi、vim）" class="headerlink" title="4.3 编辑文件（vi、vim）"></a>4.3 编辑文件（vi、vim）</h3><h3 id="4-4-查看文件-tail、cat、less、more"><a href="#4-4-查看文件-tail、cat、less、more" class="headerlink" title="4.4 查看文件(tail、cat、less、more)"></a>4.4 查看文件(tail、cat、less、more)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.txt          //查看文件最后一屏内容<br>less a.txt         //PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看<br>more a.txt         //显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看<br>tail -100 a.txt    //查看文件的后100行，&quot;Ctrl+C&quot;退出查看<br></code></pre></td></tr></table></figure><h2 id="5-文件权限"><a href="#5-文件权限" class="headerlink" title="5.文件权限"></a>5.文件权限</h2><h3 id="5-1-权限说明"><a href="#5-1-权限说明" class="headerlink" title="5.1 权限说明"></a>5.1 权限说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">文件权限简介：&#x27;r&#x27; 代表可读（4），&#x27;w&#x27; 代表可写（2），&#x27;x&#x27; 代表执行权限（1），括号内代表&quot;8421法&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#文件权限信息示例：-rwxrw-r--</span></span><br>-第一位：&#x27;-&#x27;就代表是文件，&#x27;d&#x27;代表是文件夹<br>-第一组三位：拥有者的权限<br>-第二组三位：拥有者所在的组，组员的权限<br>-第三组三位：代表的是其他用户的权限<br></code></pre></td></tr></table></figure><h3 id="5-2-文件权限"><a href="#5-2-文件权限" class="headerlink" title="5.2 文件权限"></a>5.2 文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">普通授权    chmod +x a.txt    <br>8421法     chmod 777 a.txt     //1+2+4=7，&quot;7&quot;说明授予所有权限<br></code></pre></td></tr></table></figure><h2 id="6-打包与解压（tar）"><a href="#6-打包与解压（tar）" class="headerlink" title="6.打包与解压（tar）"></a>6.打包与解压（tar）</h2><h3 id="6-1-说明"><a href="#6-1-说明" class="headerlink" title="6.1 说明"></a>6.1 说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.zip、.rar        //windows系统中压缩文件的扩展名<br>.tar              //Linux中打包文件的扩展名<br>.gz               //Linux中压缩文件的扩展名<br>.tar.gz           //Linux中打包并压缩文件的扩展名<br></code></pre></td></tr></table></figure><h3 id="6-2-打包文件"><a href="#6-2-打包文件" class="headerlink" title="6.2 打包文件"></a>6.2 打包文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf 打包压缩后的文件名 要打包的文件<br>参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;<br>示例：<br>tar -zcvf a.tar file1 file2,...      //多个文件压缩打包<br></code></pre></td></tr></table></figure><h3 id="6-3-解压文件"><a href="#6-3-解压文件" class="headerlink" title="6.3 解压文件"></a>6.3 解压文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf a.tar                      //解包至当前目录<br>tar -zxvf a.tar -C /usr------        //指定解压的位置<br>unzip test.zip             //解压*.zip文件 <br>unzip -l test.zip          //查看*.zip文件的内容 <br></code></pre></td></tr></table></figure><h2 id="7-其他常用命令"><a href="#7-其他常用命令" class="headerlink" title="7. 其他常用命令"></a>7. 其他常用命令</h2><h3 id="7-1-find"><a href="#7-1-find" class="headerlink" title="7.1 find"></a>7.1 find</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*.c&quot;     //将目前目录及其子目录下所有延伸档名是 c 的文件列出来<br>find . -type f         //将目前目录其其下子目录中所有一般文件列出<br>find . -ctime -20      //将目前目录及其子目录下所有最近 20 天内更新过的文件列出<br>find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;     //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们<br>find . -type f -perm 644 -exec ls -l &#123;&#125; \;       //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br>find / -type f -size 0 -exec ls -l &#123;&#125; \;         //为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br></code></pre></td></tr></table></figure><h3 id="7-2-whereis"><a href="#7-2-whereis" class="headerlink" title="7.2 whereis"></a>7.2 whereis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whereis ls             //将和ls文件相关的文件都查找出来<br></code></pre></td></tr></table></figure><h3 id="7-3-grep"><a href="#7-3-grep" class="headerlink" title="7.3 grep"></a>7.3 grep</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -i &quot;the&quot; demo_file              //在文件中查找字符串(不区分大小写)<br>grep -A 3 -i &quot;example&quot; demo_text     //输出成功匹配的行，以及该行之后的三行<br>grep -r &quot;ramesh&quot; *                   //在一个文件夹中递归查询包含指定字符串的文件<br></code></pre></td></tr></table></figure><h3 id="7-4-free"><a href="#7-4-free" class="headerlink" title="7.4 free"></a>7.4 free</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">说明：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况 <br>free -g            //以G为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节 <br>free -t            //查看所有内存的汇总<br></code></pre></td></tr></table></figure><h3 id="7-5-top"><a href="#7-5-top" class="headerlink" title="7.5 top"></a>7.5 top</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top               //显示当前系统中占用资源最多的一些进程, shift+m 按照内存大小查看<br></code></pre></td></tr></table></figure><h3 id="7-6-df"><a href="#7-6-df" class="headerlink" title="7.6 df"></a>7.6 df</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">说明：显示文件系统的磁盘使用情况<br>df -h            //一种易看的显示<br></code></pre></td></tr></table></figure><h3 id="7-7-ssh"><a href="#7-7-ssh" class="headerlink" title="7.7 ssh"></a>7.7 ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@remote -p port<br>//user 是你在远程机器上的用户名，如果不指定的话默认为当前用户<br>//remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名<br>//port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22<br></code></pre></td></tr></table></figure><h3 id="7-8-scp"><a href="#7-8-scp" class="headerlink" title="7.8 scp"></a>7.8 scp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /opt/data.txt  192.168.1.101:/opt/    //将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下<br></code></pre></td></tr></table></figure><h3 id="7-9-查看进程"><a href="#7-9-查看进程" class="headerlink" title="7.9 查看进程"></a>7.9 查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef         //查看所有正在运行的进程<br></code></pre></td></tr></table></figure><h3 id="7-10-结束进程"><a href="#7-10-结束进程" class="headerlink" title="7.10 结束进程"></a>7.10 结束进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill pid       //杀死该pid的进程<br>kill -9 pid    //强制杀死该进程   <br></code></pre></td></tr></table></figure><h3 id="7-11-查看链接"><a href="#7-11-查看链接" class="headerlink" title="7.11 查看链接"></a>7.11 查看链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping IP        //查看与此IP地址的连接情况<br>netstat -an    //查看当前系统端口<br>netstat -an | grep 8080     //查看指定端口<br></code></pre></td></tr></table></figure><h3 id="7-12-查看网络"><a href="#7-12-查看网络" class="headerlink" title="7.12 查看网络"></a>7.12 查看网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h2 id="8-实用命令"><a href="#8-实用命令" class="headerlink" title="8.实用命令"></a>8.实用命令</h2><p>看8080端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nap|grep :8080   <br>//结果分别为：<br>协议名-网络接受队列-网络发送队列-本地地址-外部地址-链路状态-进程ip/应用程序<br></code></pre></td></tr></table></figure><p>强制杀死所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 `ps -aux|awk &#x27;&#123;print $2&#125;&#x27;`<br></code></pre></td></tr></table></figure><p>忽略大小写匹配a的行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -o -i &#x27;a&#x27; aaa.txt|wc -l<br></code></pre></td></tr></table></figure><p>查找最后500行日志的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Tail -n 500 文件名<br></code></pre></td></tr></table></figure><p>grep擅长查找，sed擅长修改文件、awk擅长取列</p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋招-liunx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/08/hello-world/"/>
    <url>/2023/10/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
